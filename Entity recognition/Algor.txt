Interface theory allow system designer reason composability compatibility concurrent system component Such theory often extend de Alfaro Henzinger � Interface Automata Larsen � Modal Transition Systems lead however several issue undesirable practice unintuitive treatment specified unwanted behaviour binary compatibility concept scale multi-component assembly compatibility guarantee insufficient software product line article show communication mismatch central problem thus ability represent error semantically important feature interface theory Accordingly present error-aware interface theory EMIA shortcoming remedied introducing explicit fatal error state addition prove via Galois insertion EMIA conservative generalisation established Modal Interface Automata theory Interface theory allow system designer reason composability compatibility concurrent system component Such theory often extend de Alfaro Henzinger � Interface Automata Larsen � Modal Transition Systems lead however several issue undesirable practice unintuitive treatment specified unwanted behaviour binary compatibility concept scale multi-component assembly compatibility guarantee insufficient software product line article show communication mismatch central problem thus ability represent error semantically important feature interface theory Accordingly present error-aware interface theory EMIA shortcoming remedied introducing explicit fatal error state addition prove via Galois insertion EMIA conservative generalisation established Modal Interface Automata theory
Extensive optimizing parallelizing transformation carried program untrusted compiler human expert deploying platform architecture large parallel It therefore important devise suitable modelling paradigm capable capturing parallelism way proving equivalence source program transformed version becomes easier present work untimed Petri net model data constraint called CPN model Coloured Petri net used model parallel behaviour Being value based model depict vividly data dependency lie core transformation accordingly likely provide suitable internal representation IRs source transformed program IRs like sequential control flow graph CFGs path based equivalence checking method CPN model rigorous treatment complexity correctness issue presented Experimental result show effectiveness approach Extensive optimizing parallelizing transformation carried program untrusted compiler human expert deploying platform architecture large parallel It therefore important devise suitable modelling paradigm capable capturing parallelism way proving equivalence source program transformed version becomes easier present work untimed Petri net model data constraint called CPN model Coloured Petri net used model parallel behaviour Being value based model depict vividly data dependency lie core transformation accordingly likely provide suitable internal representation IRs source transformed program IRs like sequential control flow graph CFGs path based equivalence checking method CPN model rigorous treatment complexity correctness issue presented Experimental result show effectiveness approach
Automated program verification often proceeds exhibiting inductive invariant entailing desired property For numerical property classical class invariant convex polyhedron solution set system linear equality Forty year research convex polyhedral invariant focused one hand identifying � easier � subclass hand heuristic finding general convex polyhedron These heuristic however guaranteed find polyhedral inductive invariant exist best knowledge existence polyhedral inductive invariant never proved undecidable article show existence convex polyhedral invariant undecidable even one control state addition � bad � one question still open one allowed nonlinear constraint Automated program verification often proceeds exhibiting inductive invariant entailing desired property For numerical property classical class invariant convex polyhedron solution set system linear equality Forty year research convex polyhedral invariant focused one hand identifying � easier � subclass hand heuristic finding general convex polyhedron These heuristic however guaranteed find polyhedral inductive invariant exist best knowledge existence polyhedral inductive invariant never proved undecidable article show existence convex polyhedral invariant undecidable even one control state addition � bad � one question still open one allowed nonlinear constraint
Consensus fundamental abstraction distributed system solvability widely discussed literature message passing distributed system need solve sequential instance consensus possible process become faulty one instance recover later another instance Though consensus algorithm equipped handle process failure process recovery little amount work done literature handle process recovery Handling process recovery trivial recovered process may broadcast new message could hamper progress made process towards achieving consensus current round thereby forcing start new round Therefore algorithm designed handle process recovery require \text O \bigl f\bigr round \text O \bigl f\delta \bigr time achieve consensus f process recover \delta message delay system But Dutta et al International conference dependable system network DSN � 05 pp 22�27 2005. http //doi.org/10.1109/DSN.2005.54 showed overhead handling process recovery constant algorithm take 17\delta time achieve consensus work introduce new Paxos based algorithm lower upper bound 11\delta also show process failure initial upper bound reduced 5\delta algorithm selectively enables process executing lower round decide irrespective presence higher round system minimizing effect recovered process starting higher round Consensus fundamental abstraction distributed system solvability widely discussed literature message passing distributed system need solve sequential instance consensus possible process become faulty one instance recover later another instance Though consensus algorithm equipped handle process failure process recovery little amount work done literature handle process recovery Handling process recovery trivial recovered process may broadcast new message could hamper progress made process towards achieving consensus current round thereby forcing start new round Therefore algorithm designed handle process recovery require \text O \bigl f\bigr round \text O \bigl f\delta \bigr time achieve consensus f process recover \delta message delay system But Dutta et al International conference dependable system network DSN � 05 pp 22�27 2005. http //doi.org/10.1109/DSN.2005.54 showed overhead handling process recovery constant algorithm take 17\delta time achieve consensus work introduce new Paxos based algorithm lower upper bound 11\delta also show process failure initial upper bound reduced 5\delta algorithm selectively enables process executing lower round decide irrespective presence higher round system minimizing effect recovered process starting higher round
study hardness deciding probabilistic termination well hardness approximating expected value program variable co variance probabilistic program study hardness deciding probabilistic termination well hardness approximating expected value program variable co variance probabilistic program
propose novel approach coping alternating quantification main source nonelementary complexity deciding WS1S formula approach applicable within state-of-the-art automata-based WS1S decision procedure implemented Mona way standard decision procedure process quantifier involves determinization worst case exponential complexity every quantifier alternation prefix formula algorithm avoids building deterministic automata�instead construct state needed dis proving validity formula It us symbolic representation state deeply nested structure stemming repeated implicit subset construction prune search space nested subsumption relation generalization one used so-called antichain algorithm handling nondeterministic automaton obtained encouraging experimental result case outperforming Mona recently proposed approach several order magnitude propose novel approach coping alternating quantification main source nonelementary complexity deciding WS1S formula approach applicable within state-of-the-art automata-based WS1S decision procedure implemented Mona way standard decision procedure process quantifier involves determinization worst case exponential complexity every quantifier alternation prefix formula algorithm avoids building deterministic automata�instead construct state needed dis proving validity formula It us symbolic representation state deeply nested structure stemming repeated implicit subset construction prune search space nested subsumption relation generalization one used so-called antichain algorithm handling nondeterministic automaton obtained encouraging experimental result case outperforming Mona recently proposed approach several order magnitude
Distributed system often organized chain component business process chain component naturally double-sided left right interface suggest corresponding highly abstract general framework mathematical term monoid component composition minimal assumption underlying global infrastructure fact global set symbol fundamental property decisive composition two component composition property turn associative discus number instantiation framework mainly class Petri net preserve important property soundness workflow composition glance number generalization specialization Distributed system often organized chain component business process chain component naturally double-sided left right interface suggest corresponding highly abstract general framework mathematical term monoid component composition minimal assumption underlying global infrastructure fact global set symbol fundamental property decisive composition two component composition property turn associative discus number instantiation framework mainly class Petri net preserve important property soundness workflow composition glance number generalization specialization
propose calculus concurrent reversible multiparty session equipped flexible choice operator allowing different set participant branch operator inspired notion connecting action recently introduced Hu Yoshida describe protocol optional participant argue choice operator allows natural description typical communication protocol calculus also support compact representation history process type facilitates definition rollback Moreover implement fine-tuned strategy backward computation present session type system calculus show enforces expected property session fidelity forward progress backward progress propose calculus concurrent reversible multiparty session equipped flexible choice operator allowing different set participant branch operator inspired notion connecting action recently introduced Hu Yoshida describe protocol optional participant argue choice operator allows natural description typical communication protocol calculus also support compact representation history process type facilitates definition rollback Moreover implement fine-tuned strategy backward computation present session type system calculus show enforces expected property session fidelity forward progress backward progress
paper introduces negotiation model concurrency close Petri net multi-party negotiation concurrency primitive study two fundamental analysis problem soundness problem consists deciding always possible negotiation terminate successfully whatever current state Given sound negotiation summarization problem aim computing equivalent one-step negotiation input/output behavior soundness summarization problem solved mean simple algorithm acting state space negotiation however face well-known state explosion problem study alternative algorithm avoid construction state space particular define reduction rule simplify negotiation preserving sound/non-sound character negotiation summary first result show rule complete class weakly deterministic acyclic negotiation meaning reduce sound negotiation class equivalent one-step negotiation provides algorithm soundness summarization problem avoid construction state space study class deterministic negotiation second main result show rule also complete class even negotiation contain cycle Moreover present algorithm completely reduces sound deterministic negotiation polynomial time paper introduces negotiation model concurrency close Petri net multi-party negotiation concurrency primitive study two fundamental analysis problem soundness problem consists deciding always possible negotiation terminate successfully whatever current state Given sound negotiation summarization problem aim computing equivalent one-step negotiation input/output behavior soundness summarization problem solved mean simple algorithm acting state space negotiation however face well-known state explosion problem study alternative algorithm avoid construction state space particular define reduction rule simplify negotiation preserving sound/non-sound character negotiation summary first result show rule complete class weakly deterministic acyclic negotiation meaning reduce sound negotiation class equivalent one-step negotiation provides algorithm soundness summarization problem avoid construction state space study class deterministic negotiation second main result show rule also complete class even negotiation contain cycle Moreover present algorithm completely reduces sound deterministic negotiation polynomial time
Component-based system evolve new component added existing one replaced newer version Hence appealing assure new system still preserve safety property However instead inspecting new system whole may result large state space beneficial reuse verification result inspecting newly added component isolation aim study problem model checking component-based asynchronously communicating system presence unspecified component safety property solution based assume-guarantee reasoning adopted asynchronous environment generates weakest assumption If newly added component conforms assumption whole system still satisfies property make approach efficient convergent produce overapproximated interface missing component composition rest system component achieve overapproximated specification system remove trace system violate property generate assumption missing component implemented approach two case study Furthermore compared result state art direct approach resulting assumption smaller size achieved faster Component-based system evolve new component added existing one replaced newer version Hence appealing assure new system still preserve safety property However instead inspecting new system whole may result large state space beneficial reuse verification result inspecting newly added component isolation aim study problem model checking component-based asynchronously communicating system presence unspecified component safety property solution based assume-guarantee reasoning adopted asynchronous environment generates weakest assumption If newly added component conforms assumption whole system still satisfies property make approach efficient convergent produce overapproximated interface missing component composition rest system component achieve overapproximated specification system remove trace system violate property generate assumption missing component implemented approach two case study Furthermore compared result state art direct approach resulting assumption smaller size achieved faster
Turi Plotkin introduced elegant approach structural operational semantics based universal coalgebra parametric type syntax type behaviour Their framework includes abstract GSOS categorical generalisation classical GSOS rule format well categorical dual coGSOS Both format well behaved sense specification unique model behavioural equivalence congruence Unfortunately combination two format feature desirable property show monotone specifications�that disallow negative premises�do induce canonical distributive law monad comonad therefore unique compositional interpretation Turi Plotkin introduced elegant approach structural operational semantics based universal coalgebra parametric type syntax type behaviour Their framework includes abstract GSOS categorical generalisation classical GSOS rule format well categorical dual coGSOS Both format well behaved sense specification unique model behavioural equivalence congruence Unfortunately combination two format feature desirable property show monotone specifications�that disallow negative premises�do induce canonical distributive law monad comonad therefore unique compositional interpretation
Few fuzzy temporal logic modeling formalism developed model checking effective efficient State-space explosion make model checking fuzzy temporal logic inefficient That either modeling formalism compact verification approach requires exponentially larger yet intermediate representation modeling formalism exemplify Fuzzy Program Graph FzPG compact powerful formalism model fuzzy system yet required translated equal Fuzzy Kripke model exponential blow-up formally verified paper introduce Fuzzy Computation Tree Logic FzCTL direct symbolic model checking FzPG avoids aforementioned state-space explosion Considering compactness readability FzPG along expressiveness FzCTL believe proposed method applicable real-world scenario Finally study formal verification fuzzy flip-flop demonstrate capability proposed method Few fuzzy temporal logic modeling formalism developed model checking effective efficient State-space explosion make model checking fuzzy temporal logic inefficient That either modeling formalism compact verification approach requires exponentially larger yet intermediate representation modeling formalism exemplify Fuzzy Program Graph FzPG compact powerful formalism model fuzzy system yet required translated equal Fuzzy Kripke model exponential blow-up formally verified paper introduce Fuzzy Computation Tree Logic FzCTL direct symbolic model checking FzPG avoids aforementioned state-space explosion Considering compactness readability FzPG along expressiveness FzCTL believe proposed method applicable real-world scenario Finally study formal verification fuzzy flip-flop demonstrate capability proposed method
seminal paper Montanari Meseguer shown algebraic interpretation Petri net term commutative monoids used provide elegant characterisation deterministic computation net accounting sequential parallel composition smoother complete theory deterministic computation later developed relying concept pre-net variation Petri net non-commutative flavor paper show along line adding idempotent operation thus considering dioids idempotent semirings rather monoids one faithfully characterise non-deterministic computation net seminal paper Montanari Meseguer shown algebraic interpretation Petri net term commutative monoids used provide elegant characterisation deterministic computation net accounting sequential parallel composition smoother complete theory deterministic computation later developed relying concept pre-net variation Petri net non-commutative flavor paper show along line adding idempotent operation thus considering dioids idempotent semirings rather monoids one faithfully characterise non-deterministic computation net
graph-controlled insertion�deletion system regulated extension insertion�deletion system It several component component contains insertion�deletion rule These component vertex directed control graph transition performed applicable rule current component string resultant string moved target component specified rule also describes arc control graph Starting axiom initial component string thus move control graph language system set terminal string collected final component paper investigate variant main question area combination size parameter maximum number component maximal length insertion string maximal length left context insertion maximal length right context insertion plus three similar restriction respect deletion sufficient maintain computational completeness restricted system additional restriction undirected control graph path ? Notice result also bear consequence domain insertion�deletion P system improving number previous result literature concerning particular number component membrane necessary computational completeness result graph-controlled insertion�deletion system regulated extension insertion�deletion system It several component component contains insertion�deletion rule These component vertex directed control graph transition performed applicable rule current component string resultant string moved target component specified rule also describes arc control graph Starting axiom initial component string thus move control graph language system set terminal string collected final component paper investigate variant main question area combination size parameter maximum number component maximal length insertion string maximal length left context insertion maximal length right context insertion plus three similar restriction respect deletion sufficient maintain computational completeness restricted system additional restriction undirected control graph path ? Notice result also bear consequence domain insertion�deletion P system improving number previous result literature concerning particular number component membrane necessary computational completeness result
volume contains extended version selected paper presented ATVA 2015 13th International Symposium Automated Technology Verification Analysis held October 12�15 2015 Shanghai China ATVA international recognized conference focusing theoretical practical aspect automated analysis verification synthesis providing international forum interaction among researcher academia industry ATVA 2015 95 regular 13 tool submission 33 paper accepted six tool paper program also included three invited talk three invited tutorial given Dino Distefano Facebook Queen Mary University London Martin Fr�nzle Carl von Ossietzky University Joost-Pieter Katoen RWTH Aachen University J Strother Moore University Texas Austin After conference invited author selection conference paper submit extended version special issue extended version went separate reviewing process volume contains extended version selected paper presented ATVA 2015 13th International Symposium Automated Technology Verification Analysis held October 12�15 2015 Shanghai China ATVA international recognized conference focusing theoretical practical aspect automated analysis verification synthesis providing international forum interaction among researcher academia industry ATVA 2015 95 regular 13 tool submission 33 paper accepted six tool paper program also included three invited talk three invited tutorial given Dino Distefano Facebook Queen Mary University London Martin Fr�nzle Carl von Ossietzky University Joost-Pieter Katoen RWTH Aachen University J Strother Moore University Texas Austin After conference invited author selection conference paper submit extended version special issue extended version went separate reviewing process
Infinite game imperfect information known undecidable unless information flow severely restricted One fundamental decidable case occurs total ordering among player player access information following one receive paper consider variation hierarchy principle synchronous game perfect recall identify new decidable class distributed synthesis problem solvable finite-state strategy particular show decidability maintained information hierarchy may change along play transient phase without hierarchical information allowed Finally interpret result term distributed system architecture Infinite game imperfect information known undecidable unless information flow severely restricted One fundamental decidable case occurs total ordering among player player access information following one receive paper consider variation hierarchy principle synchronous game perfect recall identify new decidable class distributed synthesis problem solvable finite-state strategy particular show decidability maintained information hierarchy may change along play transient phase without hierarchical information allowed Finally interpret result term distributed system architecture
Mean-payoff game MPGs infinite duration two-player zero-sum game played weighted graph Under hypothesis full observation admit memoryless optimal strategy player solved \mathsf NP \cap \mathsf coNP MPGs suitable quantitative model open reactive system However context assumption full observation always realistic For partial-observation case problem asks first player observation-based winning strategy enforces given threshold mean payoff undecidable paper study window mean-payoff objective introduced recently alternative classical mean-payoff objective show sharp contrast classical mean-payoff objective window mean-payoff objective decidable game partial observation Mean-payoff game MPGs infinite duration two-player zero-sum game played weighted graph Under hypothesis full observation admit memoryless optimal strategy player solved \mathsf NP \cap \mathsf coNP MPGs suitable quantitative model open reactive system However context assumption full observation always realistic For partial-observation case problem asks first player observation-based winning strategy enforces given threshold mean payoff undecidable paper study window mean-payoff objective introduced recently alternative classical mean-payoff objective show sharp contrast classical mean-payoff objective window mean-payoff objective decidable game partial observation
Of special interest formal verification safety specification assert system stay within allowed region nothing � bad � happens Equivalently computation violates safety specification � bad prefix � �a prefix whose extension violate specification theoretical property safety specification well practical advantage respect general specification widely studied Safety binary specification either safety safety introduce quantitative measure safety Intuitively safety level language L measure fraction word L bad prefix particular safety language safety level liveness language safety level Thus study span spectrum traditional safety liveness formal definition safety level based probability measure probability random word L bad prefix study problem finding safety level language given mean deterministic nondeterministic automaton well LTL formula problem deciding membership specific class along spectrum safety almost-safety fraction-safety etc. also study property different class structure deterministic automaton Of special interest formal verification safety specification assert system stay within allowed region nothing � bad � happens Equivalently computation violates safety specification � bad prefix � �a prefix whose extension violate specification theoretical property safety specification well practical advantage respect general specification widely studied Safety binary specification either safety safety introduce quantitative measure safety Intuitively safety level language L measure fraction word L bad prefix particular safety language safety level liveness language safety level Thus study span spectrum traditional safety liveness formal definition safety level based probability measure probability random word L bad prefix study problem finding safety level language given mean deterministic nondeterministic automaton well LTL formula problem deciding membership specific class along spectrum safety almost-safety fraction-safety etc. also study property different class structure deterministic automaton
TSO-to-TSO linearizability variant linearizability concurrent library total store order TSO memory model It proved paper TSO-to-TSO linearizability bounded number process undecidable first show trace inclusion problem classic-lossy single-channel system known undecidable reduced history inclusion problem specific library TSO memory model Based equivalence history inclusion extended history inclusion library prove extended history inclusion problem library undecidable TSO memory model By mean extended history inclusion equivalent characterization TSO-to-TSO linearizability finally prove TSO-to-TSO linearizability undecidable bounded number process Additionally prove variant history inclusion problem undecidable TSO bounded number process TSO-to-TSO linearizability variant linearizability concurrent library total store order TSO memory model It proved paper TSO-to-TSO linearizability bounded number process undecidable first show trace inclusion problem classic-lossy single-channel system known undecidable reduced history inclusion problem specific library TSO memory model Based equivalence history inclusion extended history inclusion library prove extended history inclusion problem library undecidable TSO memory model By mean extended history inclusion equivalent characterization TSO-to-TSO linearizability finally prove TSO-to-TSO linearizability undecidable bounded number process Additionally prove variant history inclusion problem undecidable TSO bounded number process
present simple model called depleatable channel multi-hop communication ad hoc network introduce model channel energy consumption propose notion channel equivalence based communication service provide regardless specific routing protocol particular consider equivalent two channel identical maximum minimum inhibiting flow prove notion equivalence variant coincide standard equivalence borrowed theory concurrency Unfortunately maximum flow computed polynomial time calculating value minimum inhibiting flow NP-hard Thus propose characterization graph called weak admit charge assignment minimum inhibiting flow strictly le maximum flow show weakness checked efficiently providing algorithm polynomial time present simple model called depleatable channel multi-hop communication ad hoc network introduce model channel energy consumption propose notion channel equivalence based communication service provide regardless specific routing protocol particular consider equivalent two channel identical maximum minimum inhibiting flow prove notion equivalence variant coincide standard equivalence borrowed theory concurrency Unfortunately maximum flow computed polynomial time calculating value minimum inhibiting flow NP-hard Thus propose characterization graph called weak admit charge assignment minimum inhibiting flow strictly le maximum flow show weakness checked efficiently providing algorithm polynomial time
paper describes synthesis procedure dedicated construction choice-free Petri net finite persistent transition system whenever possible Taking advantage property choice-free Petri net two-step approach proposed pre-synthesis step check necessary structural property transition system construct data structure needed second step Then minimised set simplified system linear inequality distilled general region-theoretic approach lead substantial narrowing set state linear inequality must solved allows early detection failure supported constructive error message performance resulting algorithm measured compared numerically existing synthesis tool paper describes synthesis procedure dedicated construction choice-free Petri net finite persistent transition system whenever possible Taking advantage property choice-free Petri net two-step approach proposed pre-synthesis step check necessary structural property transition system construct data structure needed second step Then minimised set simplified system linear inequality distilled general region-theoretic approach lead substantial narrowing set state linear inequality must solved allows early detection failure supported constructive error message performance resulting algorithm measured compared numerically existing synthesis tool
paper analyze M/M/1 queue batch arrival multiple working vacation describe queueing model special GI/M/1 type Markov process infinite phase matrix analytic method give stationary queue length distribution model also obtain exact number vacation completed server paper analyze M/M/1 queue batch arrival multiple working vacation describe queueing model special GI/M/1 type Markov process infinite phase matrix analytic method give stationary queue length distribution model also obtain exact number vacation completed server
Extended BNF grammar EBNF allow regular expression right part rule They widely used define language represented recursive Transition Networks TN consisting set finite-state machine present novel direct construction efficient shift-reduce ELR parser TNs show parser work deterministically TN free classical shift-reduce reduce�reduce conflict LR parser new conflict type called convergence conflict Such novel condition determinism proved correct general proposed past EBNF grammar TNs Such ELR parser perform fewer shift move equivalent LR parser simple optimization reduction move described Extended BNF grammar EBNF allow regular expression right part rule They widely used define language represented recursive Transition Networks TN consisting set finite-state machine present novel direct construction efficient shift-reduce ELR parser TNs show parser work deterministically TN free classical shift-reduce reduce�reduce conflict LR parser new conflict type called convergence conflict Such novel condition determinism proved correct general proposed past EBNF grammar TNs Such ELR parser perform fewer shift move equivalent LR parser simple optimization reduction move described
special issue Acta Informatica dedicated 20th anniversary edition International Symposium Formal Methods FM 2015 held Oslo June 21�25 special issue Acta Informatica dedicated 20th anniversary edition International Symposium Formal Methods FM 2015 held Oslo June 21�25
Weak distribution bisimilarity equivalence notion probabilistic automaton originally proposed Markov automaton It gained popularity coarsest behavioral equivalence enjoying valuable property like preservation trace distribution equivalence compositionality hold classical context arbitrary scheduler argued class scheduler unrealistically powerful paper study strictly coarser notion bisimilarity still enjoys property context realistic subclass scheduler Trace distribution equivalence implied partial information scheduler compositionality preserved distributed scheduler intersection two scheduler class thus span coarser still reasonable compositional theory behavioral semantics Weak distribution bisimilarity equivalence notion probabilistic automaton originally proposed Markov automaton It gained popularity coarsest behavioral equivalence enjoying valuable property like preservation trace distribution equivalence compositionality hold classical context arbitrary scheduler argued class scheduler unrealistically powerful paper study strictly coarser notion bisimilarity still enjoys property context realistic subclass scheduler Trace distribution equivalence implied partial information scheduler compositionality preserved distributed scheduler intersection two scheduler class thus span coarser still reasonable compositional theory behavioral semantics
static analysis abstract interpretation typically composed ascending phase followed descending one descending phase used improve precision analysis post-fixpoint reached Termination often guaranteed using narrowing operator especially numerical domain generally endowed infinite descending chain Under hypothesis dealing reducible flow graph provide abstract semantics improves analysis precision show large class numerical abstract domain integer variable interval octagon template parallelotopes template polyhedron infinite descending chain arise safely omit narrowing abstract semantics slight variation standard one easily implemented also provide acceleration procedure ensures termination descending phase without narrowing even non-reducible graph Finally propose new family weak narrowing operator real variable improve analysis precision static analysis abstract interpretation typically composed ascending phase followed descending one descending phase used improve precision analysis post-fixpoint reached Termination often guaranteed using narrowing operator especially numerical domain generally endowed infinite descending chain Under hypothesis dealing reducible flow graph provide abstract semantics improves analysis precision show large class numerical abstract domain integer variable interval octagon template parallelotopes template polyhedron infinite descending chain arise safely omit narrowing abstract semantics slight variation standard one easily implemented also provide acceleration procedure ensures termination descending phase without narrowing even non-reducible graph Finally propose new family weak narrowing operator real variable improve analysis precision
explore complexity reachability run-time refinement safety liveness constraint event-based process model study framed DCR\ ^\star process language support modular specification compositional operational semantics DCR\ ^\star encompasses � Dynamic Condition Response DCR graph � declarative process model analysis execution safe run-time refinement process-aware information system including replication sub-processes prove event-reachability refinement np-hard DCR\ ^\star process without replication finite state process recognise exactly language union regular \omega -regular language Moreover prove event-reachability refinement undecidable general DCR\ ^\star process replication local event provide tractable approximation refinement prototype implementation DCR\ ^\star language available http //dcr.tools/acta16 explore complexity reachability run-time refinement safety liveness constraint event-based process model study framed DCR\ ^\star process language support modular specification compositional operational semantics DCR\ ^\star encompasses � Dynamic Condition Response DCR graph � declarative process model analysis execution safe run-time refinement process-aware information system including replication sub-processes prove event-reachability refinement np-hard DCR\ ^\star process without replication finite state process recognise exactly language union regular \omega -regular language Moreover prove event-reachability refinement undecidable general DCR\ ^\star process replication local event provide tractable approximation refinement prototype implementation DCR\ ^\star language available http //dcr.tools/acta16
Certain upper triangular matrix termed Parikh matrix often used combinatorial study word Given word Parikh matrix word elegantly computes number occurrence certain predefined subwords word paper compute Parikh matrix word raised arbitrary power Furthermore propose canonical decomposition Parikh matrix word normal form Finally given Parikh matrix relation normal form normal form word corresponding M-equivalence class established Certain upper triangular matrix termed Parikh matrix often used combinatorial study word Given word Parikh matrix word elegantly computes number occurrence certain predefined subwords word paper compute Parikh matrix word raised arbitrary power Furthermore propose canonical decomposition Parikh matrix word normal form Finally given Parikh matrix relation normal form normal form word corresponding M-equivalence class established
aim study understand inherent expressive power CTL operator investigate complexity model checking CTL fragment one CTL operator arbitrary Boolean operator give u fingerprint CTL operator comparison fingerprint yield hierarchy operator mirror strength respect model checking aim study understand inherent expressive power CTL operator investigate complexity model checking CTL fragment one CTL operator arbitrary Boolean operator give u fingerprint CTL operator comparison fingerprint yield hierarchy operator mirror strength respect model checking
It always interesting subject investigate whether three-element language code paper consider special class three-element language two word length le length third word give necessary sufficient condition state whether three-element language class code result partially resolve problem proposed Professor H. J. Shyr 1990s It always interesting subject investigate whether three-element language code paper consider special class three-element language two word length le length third word give necessary sufficient condition state whether three-element language class code result partially resolve problem proposed Professor H. J. Shyr 1990s
Formal specification language lot notion common They introduce entity usually called process offer similar operator importantly define operational semantics based labelled transition system LTS However language defines specific synchronizing and/or memory structure For instance CSP synchronization defined identical event CCS synchronization vectors-based view defined respectively complementary event possibly different event paper aim capturing similarity specification language defining label-based formal framework reasoning LTS semantics related property Firstly define high-level synchronization mechanism form abstract label structure identify property Then introduce operator composing transforming label structure study intrinsic property explore label structure property propagate Secondly introduce LTS-based behavioral framework lift label structure composition transformation operator LTS level establish LTS-related property derived underlying labelled structure Thirdly consider extended transition system specifically timed automaton LTS built top specific labelled structure Their semantics reconstructed applying operator framework syntactic LTS allows direct proof semantic property compositionality Formal specification language lot notion common They introduce entity usually called process offer similar operator importantly define operational semantics based labelled transition system LTS However language defines specific synchronizing and/or memory structure For instance CSP synchronization defined identical event CCS synchronization vectors-based view defined respectively complementary event possibly different event paper aim capturing similarity specification language defining label-based formal framework reasoning LTS semantics related property Firstly define high-level synchronization mechanism form abstract label structure identify property Then introduce operator composing transforming label structure study intrinsic property explore label structure property propagate Secondly introduce LTS-based behavioral framework lift label structure composition transformation operator LTS level establish LTS-related property derived underlying labelled structure Thirdly consider extended transition system specifically timed automaton LTS built top specific labelled structure Their semantics reconstructed applying operator framework syntactic LTS allows direct proof semantic property compositionality
Parity game play central role model checking satisfiability checking Solving parity game computationally expensive among others due size game model checking problem easily contain 10^9\ vertex beyond Equivalence relation used reduce size parity game thereby potentially alleviating part computational burden reconsider governed bisimulation governed stuttering bisimulation give detailed proof relation equivalence unique quotient approximate winning region parity game Furthermore present game-based characterisation relation Using characterisation equivalence compared relation parity game found literature direct simulation equivalence delayed simulation equivalence complete overview develop coinductive characterisation direct- delayed simulation equivalence establish lattice equivalence parity game Parity game play central role model checking satisfiability checking Solving parity game computationally expensive among others due size game model checking problem easily contain 10^9\ vertex beyond Equivalence relation used reduce size parity game thereby potentially alleviating part computational burden reconsider governed bisimulation governed stuttering bisimulation give detailed proof relation equivalence unique quotient approximate winning region parity game Furthermore present game-based characterisation relation Using characterisation equivalence compared relation parity game found literature direct simulation equivalence delayed simulation equivalence complete overview develop coinductive characterisation direct- delayed simulation equivalence establish lattice equivalence parity game
combine three extension context-free grammar associating nonterminals storage configuration b equipping rule weight c controlling derivation For commutative semiring K introduce class weighted language generated K-weighted linear context-free grammar storage S derivation controlled S K -recognizable weighted language control derivation iterated natural way characterize n-th iteration control term n-th iteration one-turn pushdown operator storage S control weighted language Moreover proper semiring prove iterating control yield infinite strict hierarchy class weighted language combine three extension context-free grammar associating nonterminals storage configuration b equipping rule weight c controlling derivation For commutative semiring K introduce class weighted language generated K-weighted linear context-free grammar storage S derivation controlled S K -recognizable weighted language control derivation iterated natural way characterize n-th iteration control term n-th iteration one-turn pushdown operator storage S control weighted language Moreover proper semiring prove iterating control yield infinite strict hierarchy class weighted language
Real-time logic popular specification language reasoning system intended meet timing constraint Numerous formalism proposed different underlying time model characterized along two dimension dense versus discrete time point-based versus interval-based present monitoring algorithm past-only fragment metric temporal logic differ along two dimension analyze complexity compare class formula point-based interval-based setting coincide comparison reveals similarity difference monitoring algorithm highlight key concept underlying prior monitoring algorithm For example point-based algorithm conceptually simpler efficient interval-based one invoked time point occurring monitored trace reasoning limited time point Real-time logic popular specification language reasoning system intended meet timing constraint Numerous formalism proposed different underlying time model characterized along two dimension dense versus discrete time point-based versus interval-based present monitoring algorithm past-only fragment metric temporal logic differ along two dimension analyze complexity compare class formula point-based interval-based setting coincide comparison reveals similarity difference monitoring algorithm highlight key concept underlying prior monitoring algorithm For example point-based algorithm conceptually simpler efficient interval-based one invoked time point occurring monitored trace reasoning limited time point
Delta-oriented programming DOP flexible approach implementation software product line SPLs Delta-oriented SPLs consist code base set delta module encapsulating change object-oriented program product line declaration providing connection delta module product feature paper present core calculus extends DOP capability switch implemented product configuration runtime dynamic delta-oriented SPL delta-oriented SPL dynamic reconfiguration graph specifies switch different feature configuration Dynamic DOP support also unanticipated software evolution runtime product line declaration code base dynamic reconfiguration graph changed unanticipated way preserve currently running product essential evolution affect existing feature type system dynamic DOP core calculus ensures dynamic reconfigurations lead type safe product cause runtime type error Delta-oriented programming DOP flexible approach implementation software product line SPLs Delta-oriented SPLs consist code base set delta module encapsulating change object-oriented program product line declaration providing connection delta module product feature paper present core calculus extends DOP capability switch implemented product configuration runtime dynamic delta-oriented SPL delta-oriented SPL dynamic reconfiguration graph specifies switch different feature configuration Dynamic DOP support also unanticipated software evolution runtime product line declaration code base dynamic reconfiguration graph changed unanticipated way preserve currently running product essential evolution affect existing feature type system dynamic DOP core calculus ensures dynamic reconfigurations lead type safe product cause runtime type error
It well-known reachability graph sum disjoint Petri net disjoint product reachability graph component shall consider converse problem i.e determine transition system may decomposed non-trivial concurrent factor extend theory general labelled transition system Meanwhile shall develop interesting algebraic property disjoint product present paper extended version Devillers Desel Yakovlev ed Proceedings 16th international conference application concurrency system design ACSD 2016 2016 It well-known reachability graph sum disjoint Petri net disjoint product reachability graph component shall consider converse problem i.e determine transition system may decomposed non-trivial concurrent factor extend theory general labelled transition system Meanwhile shall develop interesting algebraic property disjoint product present paper extended version Devillers Desel Yakovlev ed Proceedings 16th international conference application concurrency system design ACSD 2016 2016
Tight security proof allow shorter security parameter better efficiency paper firstly present new signature scheme SSSTR strongly existentially unforgeable adaptively chosen message attack whose security tightly related Strong Diffie�Hellman assumption standard model give two identity-based signature existentially unforgeable adaptively chosen message identity attack whose security also tightly related Strong Diffie�Hellman assumption standard model Tight security proof allow shorter security parameter better efficiency paper firstly present new signature scheme SSSTR strongly existentially unforgeable adaptively chosen message attack whose security tightly related Strong Diffie�Hellman assumption standard model give two identity-based signature existentially unforgeable adaptively chosen message identity attack whose security also tightly related Strong Diffie�Hellman assumption standard model
determine complexity counting model bounded size specification expressed linear-time temporal logic Counting word-models # P-complete bound given unary hard counting accepting run nondeterministic polynomial space Turing machine bound given binary Counting tree-models hard counting accepting run nondeterministic exponential time Turing machine bound given unary For binary encoding bound problem least hard counting accepting run nondeterministic exponential space Turing machine harder counting accepting run nondeterministic doubly-exponential time Turing machine Finally counting arbitrary transition system satisfying formula # P-hard harder counting accepting run nondeterministic polynomial time Turing machine PSPACE oracle bound given unary If bound given binary counting arbitrary model hard counting accepting run nondeterministic exponential time Turing machine determine complexity counting model bounded size specification expressed linear-time temporal logic Counting word-models # P-complete bound given unary hard counting accepting run nondeterministic polynomial space Turing machine bound given binary Counting tree-models hard counting accepting run nondeterministic exponential time Turing machine bound given unary For binary encoding bound problem least hard counting accepting run nondeterministic exponential space Turing machine harder counting accepting run nondeterministic doubly-exponential time Turing machine Finally counting arbitrary transition system satisfying formula # P-hard harder counting accepting run nondeterministic polynomial time Turing machine PSPACE oracle bound given unary If bound given binary counting arbitrary model hard counting accepting run nondeterministic exponential time Turing machine
Given large set measurement data order identify simple function capture essence data suggest representing data abstract function particular polynomial interpolate datapoints define polynomial would represent data succinctly interpolation challenging since practice data noisy even Byzantine Byzantine data represents adversarial value limited close correct measured data present two solution one extends Welch-Berlekamp technique Error correction algebraic block code 1986 eliminate outlier appearance case multidimensional data cope discrete noise Byzantine data solution based Arora Khot J Comput Syst Sci 67 :325�340 2003 method handle noisy data generalized case multidimensional noisy Byzantine data Given large set measurement data order identify simple function capture essence data suggest representing data abstract function particular polynomial interpolate datapoints define polynomial would represent data succinctly interpolation challenging since practice data noisy even Byzantine Byzantine data represents adversarial value limited close correct measured data present two solution one extends Welch-Berlekamp technique Error correction algebraic block code 1986 eliminate outlier appearance case multidimensional data cope discrete noise Byzantine data solution based Arora Khot J Comput Syst Sci 67 :325�340 2003 method handle noisy data generalized case multidimensional noisy Byzantine data
Reaction system qualitative formalism modelling system biochemical reaction original formulation reaction system executes environment context supply new object evolution step context drive behaviour reaction system provide different input system lead different behaviour order faithfully deal open system paper propose powerful notion context capability provide object also absorb remove object evolution step For reaction system generalized context investigate property dynamic causality revising previously proposed concept formula based predictor formula based predictor Boolean formula characterising context lead production certain object given number step paper revise theory formula based predictor order deal reaction system executed context new kind application show example interaction biochemical pathway reaction system modelling cell metabolism respiration Reaction system qualitative formalism modelling system biochemical reaction original formulation reaction system executes environment context supply new object evolution step context drive behaviour reaction system provide different input system lead different behaviour order faithfully deal open system paper propose powerful notion context capability provide object also absorb remove object evolution step For reaction system generalized context investigate property dynamic causality revising previously proposed concept formula based predictor formula based predictor Boolean formula characterising context lead production certain object given number step paper revise theory formula based predictor order deal reaction system executed context new kind application show example interaction biochemical pathway reaction system modelling cell metabolism respiration
International Symposium Games Automata Logics Formal Verification GandALF founded 2010 number Italian computer scientist interested mathematical logic automaton theory game theory application specification design verification complex system Even though idea symposium emerged within Italian research community event truly international nature witnessed composition conference committee distribution country submitted paper International Symposium Games Automata Logics Formal Verification GandALF founded 2010 number Italian computer scientist interested mathematical logic automaton theory game theory application specification design verification complex system Even though idea symposium emerged within Italian research community event truly international nature witnessed composition conference committee distribution country submitted paper
continue investigation parameterized extension linear temporal logic LTL retain attractive algorithmic property LTL polynomial space model checking algorithm doubly-exponential time algorithm solving game Alur et al Kupferman et al showed case parametric LTL PLTL PROMPT-LTL respectively temporal operator equipped variable bound scope time Later also shown true parametric LDL PLDL extends PLTL able express \omega -regular property Here generalize PLTL system cost i.e bound scope operator time bound scope term cost accumulated time Again show model checking solving game specification PLTL cost harder corresponding problem LTL Finally discus PLDL cost extension multiple cost function continue investigation parameterized extension linear temporal logic LTL retain attractive algorithmic property LTL polynomial space model checking algorithm doubly-exponential time algorithm solving game Alur et al Kupferman et al showed case parametric LTL PLTL PROMPT-LTL respectively temporal operator equipped variable bound scope time Later also shown true parametric LDL PLDL extends PLTL able express \omega -regular property Here generalize PLTL system cost i.e bound scope operator time bound scope term cost accumulated time Again show model checking solving game specification PLTL cost harder corresponding problem LTL Finally discus PLDL cost extension multiple cost function
Extensions finite-state automaton string multi-head automaton multi-counter automaton successfully used encode many infinite-state non-regular verification problem paper consider generalization automata-theoretic infinite-state verification string labelled series�parallel graph define model non-deterministic 2-way concurrent automaton working series�parallel graph communicating shared register node graph consider following verification problem given family series�parallel graph described context-free graph transformation system GTS concurrent automaton series�parallel graph graph generated GTS accepted automaton ? general problem undecidable already one-way multi-head automaton string show bounded version automaton make fixed number reversal along graph use fixed number shared register decidable even though bound size series�parallel graph generated GTS decidability result based establishing number context switch bounded encoding computation bounded concurrent automaton allows u reduce reachability problem emptiness problem pushdown automaton Extensions finite-state automaton string multi-head automaton multi-counter automaton successfully used encode many infinite-state non-regular verification problem paper consider generalization automata-theoretic infinite-state verification string labelled series�parallel graph define model non-deterministic 2-way concurrent automaton working series�parallel graph communicating shared register node graph consider following verification problem given family series�parallel graph described context-free graph transformation system GTS concurrent automaton series�parallel graph graph generated GTS accepted automaton ? general problem undecidable already one-way multi-head automaton string show bounded version automaton make fixed number reversal along graph use fixed number shared register decidable even though bound size series�parallel graph generated GTS decidability result based establishing number context switch bounded encoding computation bounded concurrent automaton allows u reduce reachability problem emptiness problem pushdown automaton
Two-player quantitative zero-sum game provide natural framework synthesize controller performance guarantee reactive system within uncontrollable environment Classical setting include mean-payoff game objective optimize long-run average gain per action energy game system avoid running energy study average-energy game goal optimize long-run average accumulated energy show objective arises naturally several application yield interesting connection previous concept literature prove deciding winner game \mathsf NP \cap \mathsf coNP least hard solving mean-payoff game establish memoryless strategy suffice win also consider case system minimize average-energy maintaining accumulated energy within predefined bound time corresponds operating finite-capacity storage energy give result one-player two-player game establish complexity bound memory requirement Two-player quantitative zero-sum game provide natural framework synthesize controller performance guarantee reactive system within uncontrollable environment Classical setting include mean-payoff game objective optimize long-run average gain per action energy game system avoid running energy study average-energy game goal optimize long-run average accumulated energy show objective arises naturally several application yield interesting connection previous concept literature prove deciding winner game \mathsf NP \cap \mathsf coNP least hard solving mean-payoff game establish memoryless strategy suffice win also consider case system minimize average-energy maintaining accumulated energy within predefined bound time corresponds operating finite-capacity storage energy give result one-player two-player game establish complexity bound memory requirement
study language equivalence problem smooth loop-free D0L system show number initial term associated D0L sequence consider decide language equivalence depends cardinality underlying alphabet study language equivalence problem smooth loop-free D0L system show number initial term associated D0L sequence consider decide language equivalence depends cardinality underlying alphabet
study containment satisfiability validity problem conjunctive query tree respect schema show conjunctive query containment validity 2EXPTIME -complete respect schema case schema given DTD tree automaton Furthermore show satisfiability conjunctive query respect schema decided NP problem NP -hard already query using one kind axis Finally consider conjunctive query test equality inequality data value Here satisfiability validity decidable containment undecidable even without schema information On hand containment respect schema becomes decidable � larger � query allowed use equality inequality study containment satisfiability validity problem conjunctive query tree respect schema show conjunctive query containment validity 2EXPTIME -complete respect schema case schema given DTD tree automaton Furthermore show satisfiability conjunctive query respect schema decided NP problem NP -hard already query using one kind axis Finally consider conjunctive query test equality inequality data value Here satisfiability validity decidable containment undecidable even without schema information On hand containment respect schema becomes decidable � larger � query allowed use equality inequality
study version online edge coloring goal color many edge possible using given number k available color All result regard competitive analysis Previous attempt identify optimal algorithm problem failed even bipartite graph Thus paper analyze even restricted graph class path tree For path consider k=2\ tree consider k \ge 2\ prove natural greedy algorithm called \textsc First-Fit optimal among deterministic algorithm path well tree For path give randomized algorithm optimal better best possible deterministic algorithm For tree prove obtain better competitive ratio \textsc First-Fit algorithm would randomized unfair i.e reject edge could colored even algorithm much better \textsc First-Fit study version online edge coloring goal color many edge possible using given number k available color All result regard competitive analysis Previous attempt identify optimal algorithm problem failed even bipartite graph Thus paper analyze even restricted graph class path tree For path consider k=2\ tree consider k \ge 2\ prove natural greedy algorithm called \textsc First-Fit optimal among deterministic algorithm path well tree For path give randomized algorithm optimal better best possible deterministic algorithm For tree prove obtain better competitive ratio \textsc First-Fit algorithm would randomized unfair i.e reject edge could colored even algorithm much better \textsc First-Fit
Instance sparsification well-known world exact computation since closely linked Exponential Time Hypothesis paper extend concept sparsification order capture subexponential time approximation develop new tool inapproximability called approximation preserving sparsification use order get strong inapproximability result subexponential time several fundamental optimization problem min dominating set min feedback vertex set min set cover min feedback arc set others Instance sparsification well-known world exact computation since closely linked Exponential Time Hypothesis paper extend concept sparsification order capture subexponential time approximation develop new tool inapproximability called approximation preserving sparsification use order get strong inapproximability result subexponential time several fundamental optimization problem min dominating set min feedback vertex set min set cover min feedback arc set others
International Conference Tools Algorithms Construction Analysis Systems TACAS forum researcher developer user interested rigorous development tool algorithm construction analysis system conference aim bridge gap different community common interest support quest improve utility reliability exibility efficiency tool algorithm building system research area covered TACAS traditionally include specification verification technique software hardware verification analytical technique real-time hybrid stochastic system analytical technique safety security dependability model checking theorem proving SAT SMT solving static dynamic program analysis testing abstraction technique modeling verification compositional refinement-based methodology system construction transformation technique tool environment tool architecture well application case study International Conference Tools Algorithms Construction Analysis Systems TACAS forum researcher developer user interested rigorous development tool algorithm construction analysis system conference aim bridge gap different community common interest support quest improve utility reliability exibility efficiency tool algorithm building system research area covered TACAS traditionally include specification verification technique software hardware verification analytical technique real-time hybrid stochastic system analytical technique safety security dependability model checking theorem proving SAT SMT solving static dynamic program analysis testing abstraction technique modeling verification compositional refinement-based methodology system construction transformation technique tool environment tool architecture well application case study
present technique efficient stateless model checking program execute relaxed memory model TSO PSO basis technique novel representation execution TSO PSO called chronological trace Chronological trace induce partial order relation relaxed memory execution capturing dependency needed represent interaction via shared variable They optimal sense distinguish computation inequivalent widely-used representation Shasha Snir allows optimal dynamic partial order reduction algorithm explore minimal number execution still guaranteeing full coverage apply technique check TSO PSO memory model LLVM assembly produced C/pthreads program experiment show technique reduces verification effort relaxed memory model almost standard model sequential consistency article extended version Abdulla et al Tools algorithm construction analysis system Springer New York pp 353�367 2015 appearing TACAS 2015 present technique efficient stateless model checking program execute relaxed memory model TSO PSO basis technique novel representation execution TSO PSO called chronological trace Chronological trace induce partial order relation relaxed memory execution capturing dependency needed represent interaction via shared variable They optimal sense distinguish computation inequivalent widely-used representation Shasha Snir allows optimal dynamic partial order reduction algorithm explore minimal number execution still guaranteeing full coverage apply technique check TSO PSO memory model LLVM assembly produced C/pthreads program experiment show technique reduces verification effort relaxed memory model almost standard model sequential consistency article extended version Abdulla et al Tools algorithm construction analysis system Springer New York pp 353�367 2015 appearing TACAS 2015
behaviour gene regulatory network GRNs typically analysed using simulation-based statistical testing-like method paper demonstrate replace approach formal verification-like method give higher assurance scalability focus Wagner � weighted GRN model varying weight used evolutionary biology model weight parameter represent gene interaction strength may change due genetic mutation For property interest synthesise constraint parameter space represent set GRNs satisfying property experimentally show parameter synthesis procedure computes mutational robustness GRNs�an important problem interest evolutionary biology�more efficiently classical simulation method specify property linear temporal logic employ symbolic bounded model checking SMT solving compute space GRNs satisfy property amount synthesizing set linear constraint weight behaviour gene regulatory network GRNs typically analysed using simulation-based statistical testing-like method paper demonstrate replace approach formal verification-like method give higher assurance scalability focus Wagner � weighted GRN model varying weight used evolutionary biology model weight parameter represent gene interaction strength may change due genetic mutation For property interest synthesise constraint parameter space represent set GRNs satisfying property experimentally show parameter synthesis procedure computes mutational robustness GRNs�an important problem interest evolutionary biology�more efficiently classical simulation method specify property linear temporal logic employ symbolic bounded model checking SMT solving compute space GRNs satisfy property amount synthesizing set linear constraint weight
# SMT model counting logical theory well-known hard problem generalizes task counting number satisfying assignment Boolean formula computing volume polytope realm satisfiability modulo theory SMT growing need model counting solver coming several application domain quantitative information flow static analysis probabilistic program paper show reduction approximate version # SMT SMT focus theory integer arithmetic linear real arithmetic propose model counting algorithm provide approximate solution formal bound approximation error They run polynomial time make polynomial number query SMT solver underlying theory exploiting � free � sophisticated heuristic implemented within modern SMT solver implemented algorithm used solve value problem model loop-free probabilistic program nondeterminism # SMT model counting logical theory well-known hard problem generalizes task counting number satisfying assignment Boolean formula computing volume polytope realm satisfiability modulo theory SMT growing need model counting solver coming several application domain quantitative information flow static analysis probabilistic program paper show reduction approximate version # SMT SMT focus theory integer arithmetic linear real arithmetic propose model counting algorithm provide approximate solution formal bound approximation error They run polynomial time make polynomial number query SMT solver underlying theory exploiting � free � sophisticated heuristic implemented within modern SMT solver implemented algorithm used solve value problem model loop-free probabilistic program nondeterminism
propose logic definition collaborative power group agent enforce different temporal objective resulting temporal cooperation logic TCL extends ATL allowing successive definition strategy agent agency Different previous logic similar aim extension cut fine line extending power maintaining low complexity model checking TCL sentence EXPTIME complete logic NL complete model advancement nonelementary logic bought disallowing close entanglement cooperation competition show allowing entanglement immediately lead nonelementary complexity implemented model checker logic shown feasibility model checking benchmark propose logic definition collaborative power group agent enforce different temporal objective resulting temporal cooperation logic TCL extends ATL allowing successive definition strategy agent agency Different previous logic similar aim extension cut fine line extending power maintaining low complexity model checking TCL sentence EXPTIME complete logic NL complete model advancement nonelementary logic bought disallowing close entanglement cooperation competition show allowing entanglement immediately lead nonelementary complexity implemented model checker logic shown feasibility model checking benchmark
Linear temporal logic LTL synthesis formal method automatically composing reactive system realizes given behavioral specification described LTL specification realizable Even whole specification unrealizable preferable synthesize best-effort reactive system That system maximally realizes partial specification Therefore categorized specification must specification never violated desirable specification violation may unavoidable paper propose method synthesizing reactive system realizes must specification strongly endeavor satisfy desirable specification general form desirable specification without assumption \mathbf G \varphi mean � \varphi always hold � approach best effort satisfy \mathbf G \varphi maximize number step satisfying \varphi interaction quantitatively evaluate number step used mean-payoff objective based LTL formula method applies Safraless approach construct safety game given must desirable specification must specification written full LTL may include assumption It transforms safety game constructed desirable specification mean-payoff game finally composes reactive system optimal strategy synchronized product game Linear temporal logic LTL synthesis formal method automatically composing reactive system realizes given behavioral specification described LTL specification realizable Even whole specification unrealizable preferable synthesize best-effort reactive system That system maximally realizes partial specification Therefore categorized specification must specification never violated desirable specification violation may unavoidable paper propose method synthesizing reactive system realizes must specification strongly endeavor satisfy desirable specification general form desirable specification without assumption \mathbf G \varphi mean � \varphi always hold � approach best effort satisfy \mathbf G \varphi maximize number step satisfying \varphi interaction quantitatively evaluate number step used mean-payoff objective based LTL formula method applies Safraless approach construct safety game given must desirable specification must specification written full LTL may include assumption It transforms safety game constructed desirable specification mean-payoff game finally composes reactive system optimal strategy synchronized product game
Formal synthesis process generating program satisfying high-level formal specification recent time effective formal synthesis method proposed based use inductive learning refer class method learn program example formal inductive synthesis paper present theoretical framework formal inductive synthesis discus formal inductive synthesis differs traditional machine learning describe oracle-guided inductive synthesis OGIS framework capture family synthesizer operate iteratively querying oracle An instance OGIS much practical impact counterexample-guided inductive synthesis CEGIS present theoretical characterization CEGIS learning program computes recursive language particular analyze relative power CEGIS variant type counterexample generated oracle varies also consider impact bounded versus unbounded memory available learning algorithm special case universe candidate program finite relate speed convergence notion teaching dimension studied machine learning theory Altogether result paper take first step towards theoretical foundation emerging field formal inductive synthesis Formal synthesis process generating program satisfying high-level formal specification recent time effective formal synthesis method proposed based use inductive learning refer class method learn program example formal inductive synthesis paper present theoretical framework formal inductive synthesis discus formal inductive synthesis differs traditional machine learning describe oracle-guided inductive synthesis OGIS framework capture family synthesizer operate iteratively querying oracle An instance OGIS much practical impact counterexample-guided inductive synthesis CEGIS present theoretical characterization CEGIS learning program computes recursive language particular analyze relative power CEGIS variant type counterexample generated oracle varies also consider impact bounded versus unbounded memory available learning algorithm special case universe candidate program finite relate speed convergence notion teaching dimension studied machine learning theory Altogether result paper take first step towards theoretical foundation emerging field formal inductive synthesis
ubiquity computation modern machine device imposes need assert correctness behavior Especially case safety-critical system designer need take measure enforce safe operation Formal method emerged research field address challenge rigorously proving system execution adhere specification correctness implementation concern assured achieve goal plethora technique nowadays available optimized different system type application domain ubiquity computation modern machine device imposes need assert correctness behavior Especially case safety-critical system designer need take measure enforce safe operation Formal method emerged research field address challenge rigorously proving system execution adhere specification correctness implementation concern assured achieve goal plethora technique nowadays available optimized different system type application domain
When treating Markov decision process MDPs large state space using explicit representation quickly becomes unfeasible Lately Wimmer et al proposed so-called symblicit algorithm synthesis optimal strategy MDPs quantitative setting expected mean-payoff algorithm based strategy iteration algorithm Howard Veinott efficiently combine symbolic explicit data structure us binary decision diagram symbolic representation aim paper show new data structure pseudo-antichains extension antichains provides another interesting alternative especially class monotonic MDPs design efficient pseudo-antichain based symblicit algorithm open source implementation two quantitative setting expected mean-payoff stochastic shortest path For two practical application coming automated planning \mathsf LTL synthesis report promising experimental result w.r.t run time memory consumption also show variant pseudo-antichains allows handle infinite state space underlying qualitative verification probabilistic lossy channel system When treating Markov decision process MDPs large state space using explicit representation quickly becomes unfeasible Lately Wimmer et al proposed so-called symblicit algorithm synthesis optimal strategy MDPs quantitative setting expected mean-payoff algorithm based strategy iteration algorithm Howard Veinott efficiently combine symbolic explicit data structure us binary decision diagram symbolic representation aim paper show new data structure pseudo-antichains extension antichains provides another interesting alternative especially class monotonic MDPs design efficient pseudo-antichain based symblicit algorithm open source implementation two quantitative setting expected mean-payoff stochastic shortest path For two practical application coming automated planning \mathsf LTL synthesis report promising experimental result w.r.t run time memory consumption also show variant pseudo-antichains allows handle infinite state space underlying qualitative verification probabilistic lossy channel system
consider problem synthesising rate parameter stochastic biochemical network given time-bounded CSL property guaranteed hold case quantitative property probability satisfying property maximised minimised method based extending CSL model checking standard uniformisation parametric model order compute safe bound satisfaction probability property develop synthesis algorithm yield answer precise within arbitrarily small tolerance value algorithm combine computation probability bound refinement sampling parameter space method precise efficient improve existing approximate technique employ discretisation refinement evaluate usefulness method synthesising rate three biologically motivated case study infection control SIR epidemic model reliability analysis molecular computation DNA walker bistability gene regulation mammalian cell cycle consider problem synthesising rate parameter stochastic biochemical network given time-bounded CSL property guaranteed hold case quantitative property probability satisfying property maximised minimised method based extending CSL model checking standard uniformisation parametric model order compute safe bound satisfaction probability property develop synthesis algorithm yield answer precise within arbitrarily small tolerance value algorithm combine computation probability bound refinement sampling parameter space method precise efficient improve existing approximate technique employ discretisation refinement evaluate usefulness method synthesising rate three biologically motivated case study infection control SIR epidemic model reliability analysis molecular computation DNA walker bistability gene regulation mammalian cell cycle
Attribute-based signature ABS novel cryptographic primitive make signing party sign message fine-grained control identifying information ABS reveals fact verified message must signed user set attribute satisfying predicate Thus ABS hide identifying information make fine-grained control signing Presently many attribute-based signature scheme proposed efficient Maji et al recently presented complete definition construction ABS monotone predicate showed three instantiation framework ABS Although practical one instantiation efficient instantiation constructed generic group model proved insecure Then Okamoto et al proposed attribute-based signature scheme standard model support generalized non-monotone predicate access structure However scheme efficient practice paper present framework ABS show detailed security model ABS Under framework present attribute-based signature scheme monotone predicate standard model choose Waters � signature scheme prototype attribute-based signature scheme Compared Maji � scheme generic group model proposed scheme constructed standard model Furthermore compared Okamoto � scheme proposed scheme efficient decreasing computation cost Attribute-based signature ABS novel cryptographic primitive make signing party sign message fine-grained control identifying information ABS reveals fact verified message must signed user set attribute satisfying predicate Thus ABS hide identifying information make fine-grained control signing Presently many attribute-based signature scheme proposed efficient Maji et al recently presented complete definition construction ABS monotone predicate showed three instantiation framework ABS Although practical one instantiation efficient instantiation constructed generic group model proved insecure Then Okamoto et al proposed attribute-based signature scheme standard model support generalized non-monotone predicate access structure However scheme efficient practice paper present framework ABS show detailed security model ABS Under framework present attribute-based signature scheme monotone predicate standard model choose Waters � signature scheme prototype attribute-based signature scheme Compared Maji � scheme generic group model proposed scheme constructed standard model Furthermore compared Okamoto � scheme proposed scheme efficient decreasing computation cost
literature notion lumpability time reversibility large Markov chain widely used efficiently study functional non-functional property computer system paper explore relation among different definition lumpability strong exact strict notion time-reversed Markov chain Specifically prove exact lumping induces strong lumping reversed Markov chain strict lumping hold forward reversed process Based result introduce class \lambda \rho -reversible Markov chain combine notion lumping time reversibility modulo state renaming show class autoreversible process previously introduced Marin Rossi Proceedings IEEE 21st international symposium modeling analysis simulation computer telecommunication system MASCOTS pp 151�160 2013 strictly contained class \lambda \rho -reversible chain literature notion lumpability time reversibility large Markov chain widely used efficiently study functional non-functional property computer system paper explore relation among different definition lumpability strong exact strict notion time-reversed Markov chain Specifically prove exact lumping induces strong lumping reversed Markov chain strict lumping hold forward reversed process Based result introduce class \lambda \rho -reversible Markov chain combine notion lumping time reversibility modulo state renaming show class autoreversible process previously introduced Marin Rossi Proceedings IEEE 21st international symposium modeling analysis simulation computer telecommunication system MASCOTS pp 151�160 2013 strictly contained class \lambda \rho -reversible chain
paper present new algorithm reduces multivalued consensus binary consensus asynchronous message-passing system made n process may commit Byzantine failure algorithm following noteworthy property assumes < n/3\ consequently optimal resilience point view us O n^2 message constant time complexity us neither signature additional computational power random number failure detector additional scheduling assumption additional synchrony assumption design reduction algorithm relies two new all-to-all communication abstraction first one allows non-faulty process reduce number proposed value c c small constant second communication abstraction allows non-faulty process compute set proposed value satisfying following property set non-faulty process singleton containing value v set non-faulty process contains v. Both communication abstraction O n^2 message complexity constant time complexity reduction multivalued Byzantine consensus binary Byzantine consensus simple sequential use communication abstraction best knowledge first asynchronous message-passing algorithm reduces multivalued consensus binary consensus O n^2 message constant time complexity measured longest causal chain message presence < n/3\ Byzantine process without using cryptography technique Moreover reduction algorithm us single instance underlying binary consensus tolerates message re-ordering Byzantine process paper present new algorithm reduces multivalued consensus binary consensus asynchronous message-passing system made n process may commit Byzantine failure algorithm following noteworthy property assumes < n/3\ consequently optimal resilience point view us O n^2 message constant time complexity us neither signature additional computational power random number failure detector additional scheduling assumption additional synchrony assumption design reduction algorithm relies two new all-to-all communication abstraction first one allows non-faulty process reduce number proposed value c c small constant second communication abstraction allows non-faulty process compute set proposed value satisfying following property set non-faulty process singleton containing value v set non-faulty process contains v. Both communication abstraction O n^2 message complexity constant time complexity reduction multivalued Byzantine consensus binary Byzantine consensus simple sequential use communication abstraction best knowledge first asynchronous message-passing algorithm reduces multivalued consensus binary consensus O n^2 message constant time complexity measured longest causal chain message presence < n/3\ Byzantine process without using cryptography technique Moreover reduction algorithm us single instance underlying binary consensus tolerates message re-ordering Byzantine process
Since 1970 reversible finite automaton generated interest among researcher till come across model reversible read one-way finite automaton accept regular language paper introduce new model one-way reversible finite automaton inspired Watson�Crick complementarity relation show model accept regular language show model accepts language accepted multi-head deterministic finite automaton Since 1970 reversible finite automaton generated interest among researcher till come across model reversible read one-way finite automaton accept regular language paper introduce new model one-way reversible finite automaton inspired Watson�Crick complementarity relation show model accept regular language show model accepts language accepted multi-head deterministic finite automaton
present extension actor model real-time including deadline associated message explicit application-level scheduling policy � earliest deadline first � associated individual actor Schedulability analysis setting amount checking whether given scheduling policy actor every task processed within designated deadline check schedulability introduce compositional automata-theoretic approach based maximal use model checking combined testing Behavioral interface define actor expects environment deadline message given assumption use model checking verify actor match behavioral interface extend timed automaton refinement notion deadline use define compatibility actor environment behavioral interface Model checking compatibility computationally hard propose special testing process show analysis decidable automate process using Uppaal model checker present extension actor model real-time including deadline associated message explicit application-level scheduling policy � earliest deadline first � associated individual actor Schedulability analysis setting amount checking whether given scheduling policy actor every task processed within designated deadline check schedulability introduce compositional automata-theoretic approach based maximal use model checking combined testing Behavioral interface define actor expects environment deadline message given assumption use model checking verify actor match behavioral interface extend timed automaton refinement notion deadline use define compatibility actor environment behavioral interface Model checking compatibility computationally hard propose special testing process show analysis decidable automate process using Uppaal model checker
Two kind automaton presented recognising new class regular context-free nominal language compare expressive power analogous proposal literature showing express novel class language Although many property classical language hold longer nominal case design slight restriction model preserve interesting one particular prove emptiness problem decidable construct intersection restricted regular context-free automaton By example walking property argue relevance model context verification resource usage pattern Two kind automaton presented recognising new class regular context-free nominal language compare expressive power analogous proposal literature showing express novel class language Although many property classical language hold longer nominal case design slight restriction model preserve interesting one particular prove emptiness problem decidable construct intersection restricted regular context-free automaton By example walking property argue relevance model context verification resource usage pattern
Recently considered possibility using bio-inspired mobility solving weak NP-complete problem Partition paper provide semi-uniform polynomial solution strong NP-complete problem Bin Packing mean membrane computing technique solution employ mobile membrane elementary membrane division Recently considered possibility using bio-inspired mobility solving weak NP-complete problem Partition paper provide semi-uniform polynomial solution strong NP-complete problem Bin Packing mean membrane computing technique solution employ mobile membrane elementary membrane division
concept pseudo-bordered pseudo-unbordered word large part motivated research theoretical DNA computing wherein Watson�Crick complementarity DNA strand modelled antimorphic involution function \theta antimorphism \theta uv =\theta v \theta u involution \theta \theta u =u\ word u v DNA alphabet particular word w said \theta -bordered pseudo-bordered exists word v \in \Sigma proper prefix w \theta v proper suffix w. word \theta -bordered \theta -unbordered paper continues exploration property case \theta morphic involution set \theta -unbordered word D_ \theta set word exactly \theta -borders D_ \theta \ge 2\ prove condition set D_ \theta disjunctive \ge 1\ set D_ \theta ^i \setminus D disjunctive i\ge 2\ D denotes set word exactly border also discus condition catenations language \theta -unbordered word remain \theta -unbordered anticipate generalization showing set \theta -bordered word context-free morphisms \theta alphabet \Sigma |\Sigma \ge 3\ \theta \ne a\ \in \Sigma \theta equal identity function \Sigma concept pseudo-bordered pseudo-unbordered word large part motivated research theoretical DNA computing wherein Watson�Crick complementarity DNA strand modelled antimorphic involution function \theta antimorphism \theta uv =\theta v \theta u involution \theta \theta u =u\ word u v DNA alphabet particular word w said \theta -bordered pseudo-bordered exists word v \in \Sigma proper prefix w \theta v proper suffix w. word \theta -bordered \theta -unbordered paper continues exploration property case \theta morphic involution set \theta -unbordered word D_ \theta set word exactly \theta -borders D_ \theta \ge 2\ prove condition set D_ \theta disjunctive \ge 1\ set D_ \theta ^i \setminus D disjunctive i\ge 2\ D denotes set word exactly border also discus condition catenations language \theta -unbordered word remain \theta -unbordered anticipate generalization showing set \theta -bordered word context-free morphisms \theta alphabet \Sigma |\Sigma \ge 3\ \theta \ne a\ \in \Sigma \theta equal identity function \Sigma
propose Curry�Howard correspondence language programming multiparty session generalisation Classical Linear Logic CLL framework proposition correspond local behaviour participant multiparty session type proof process proof normalisation executing communication key contribution generalising duality CLL new notion n-ary compatibility called coherence Building coherence principle compositionality generalise cut rule CLL new rule composing many process communicating multiparty session prove soundness model showing admissibility new rule entail deadlock-freedom via correspondence propose Curry�Howard correspondence language programming multiparty session generalisation Classical Linear Logic CLL framework proposition correspond local behaviour participant multiparty session type proof process proof normalisation executing communication key contribution generalising duality CLL new notion n-ary compatibility called coherence Building coherence principle compositionality generalise cut rule CLL new rule composing many process communicating multiparty session prove soundness model showing admissibility new rule entail deadlock-freedom via correspondence
For higher-order process language characterising contextual equivalence long-standing issue setting higher-order \pi -calculus session type develop characteristic bisimilarity typed bisimilarity fully characterises contextual equivalence knowledge first characterisation kind Using simple value inhabiting session type approach distinguishes untyped method characterising contextual equivalence higher-order process show observing input precise finite set higher-order value suffices reason higher-order session process demonstrate characteristic bisimilarity used justify optimisation session protocol mobile code communication For higher-order process language characterising contextual equivalence long-standing issue setting higher-order \pi -calculus session type develop characteristic bisimilarity typed bisimilarity fully characterises contextual equivalence knowledge first characterisation kind Using simple value inhabiting session type approach distinguishes untyped method characterising contextual equivalence higher-order process show observing input precise finite set higher-order value suffices reason higher-order session process demonstrate characteristic bisimilarity used justify optimisation session protocol mobile code communication
Population protocol Angluin et al PODC 2004 formal model sensor network consisting identical mobile device Two device interact thereby change state Computations infinite sequence interaction satisfying strong fairness constraint population protocol well specified every initial configuration C device every computation starting C device eventually agree consensus value depending C. If protocol well specified said compute predicate assigns initial configuration consensus value While computational power well-specified protocol extensively studied two basic verification problem remain open Is given protocol well specified ? Does given protocol compute given predicate ? prove problem decidable reduction reachability problem Petri net also give new proof fact predicate computed well-defined protocol definable Presburger arithmetic Angluin et al PODC 2006 Population protocol Angluin et al PODC 2004 formal model sensor network consisting identical mobile device Two device interact thereby change state Computations infinite sequence interaction satisfying strong fairness constraint population protocol well specified every initial configuration C device every computation starting C device eventually agree consensus value depending C. If protocol well specified said compute predicate assigns initial configuration consensus value While computational power well-specified protocol extensively studied two basic verification problem remain open Is given protocol well specified ? Does given protocol compute given predicate ? prove problem decidable reduction reachability problem Petri net also give new proof fact predicate computed well-defined protocol definable Presburger arithmetic Angluin et al PODC 2006
Bisimulation up-to enhances coinductive proof method bisimilarity providing efficient proof technique checking property different kind system prove soundness technique fibrational setting building seminal work Hermida Jacobs allows u systematically obtain up-to technique bisimilarity large class coinductive predicate modeled coalgebras fact bisimulations context safely used language specified GSOS rule also seen instance framework using well-known observation Turi Plotkin language form bialgebras second part paper provide new categorical treatment weak bisimilarity labeled transition system prove soundness up-to context weak bisimulations system specified cool rule format defined Bloom ensure congruence weak bisimilarity weak transition system obtained cool rule give rise lax bialgebras rather bialgebras Hence reach goal extend categorical framework developed first part ordered setting Bisimulation up-to enhances coinductive proof method bisimilarity providing efficient proof technique checking property different kind system prove soundness technique fibrational setting building seminal work Hermida Jacobs allows u systematically obtain up-to technique bisimilarity large class coinductive predicate modeled coalgebras fact bisimulations context safely used language specified GSOS rule also seen instance framework using well-known observation Turi Plotkin language form bialgebras second part paper provide new categorical treatment weak bisimilarity labeled transition system prove soundness up-to context weak bisimulations system specified cool rule format defined Bloom ensure congruence weak bisimilarity weak transition system obtained cool rule give rise lax bialgebras rather bialgebras Hence reach goal extend categorical framework developed first part ordered setting
study problem finite-horizon probabilistic invariance discrete-time Markov process general uncountable state space compute discrete-time finite-state Markov chain formal abstraction given Markov process abstraction differs existing approach two way first exploit structure underlying Markov process compute abstraction separately dimension second employ dynamic Bayesian network DBN compact representation abstraction contrast approach represent store exponentially large Markov chain explicitly incur significantly higher memory requirement experiment explicit representation scaled model dimension le half size analyzable DBN representation show construct DBN abstraction Markov process satisfying independence assumption driving process noise compute guaranteed bound error abstraction w.r.t probabilistic invariance property�the dimension-dependent abstraction make error bound precise existing approach Additionally show factor graph sum-product algorithm DBNs used solve finite-horizon probabilistic invariance problem Together DBN-based representation algorithm significantly efficient explicit representation Markov chain abstracting model checking structured Markov process study problem finite-horizon probabilistic invariance discrete-time Markov process general uncountable state space compute discrete-time finite-state Markov chain formal abstraction given Markov process abstraction differs existing approach two way first exploit structure underlying Markov process compute abstraction separately dimension second employ dynamic Bayesian network DBN compact representation abstraction contrast approach represent store exponentially large Markov chain explicitly incur significantly higher memory requirement experiment explicit representation scaled model dimension le half size analyzable DBN representation show construct DBN abstraction Markov process satisfying independence assumption driving process noise compute guaranteed bound error abstraction w.r.t probabilistic invariance property�the dimension-dependent abstraction make error bound precise existing approach Additionally show factor graph sum-product algorithm DBNs used solve finite-horizon probabilistic invariance problem Together DBN-based representation algorithm significantly efficient explicit representation Markov chain abstracting model checking structured Markov process
February April June 2017 issue Acta Informatica devoted presenting carefully refereed full version selected paper CONCUR 2015 26th International Conference Concurrency Theory whose program committee pleasure co-chairing February April June 2017 issue Acta Informatica devoted presenting carefully refereed full version selected paper CONCUR 2015 26th International Conference Concurrency Theory whose program committee pleasure co-chairing
Two-player zero-sum game infinite duration quantitative version used verification model interaction controller Eve environment Adam question usually addressed existence computability strategy Eve maximize payoff strategy Adam work interested strategy Eve minimize regret i.e strategy minimize difference actual payoff payoff could achieved known strategy Adam advance give algorithm compute strategy Eve ensure minimal regret adversary whose choice strategy unrestricted limited positional strategy limited word strategy show two last case natural modelling application These result apply quantitative game defined classical payoff function \mathsf Inf \mathsf Sup \mathsf LimInf \mathsf LimSup mean-payoff also show notion regret minimization Adam limited word strategy generalizes notion good game introduced Henzinger Piterman related notion determinization pruning due Aminof Kupferman Lampert Two-player zero-sum game infinite duration quantitative version used verification model interaction controller Eve environment Adam question usually addressed existence computability strategy Eve maximize payoff strategy Adam work interested strategy Eve minimize regret i.e strategy minimize difference actual payoff payoff could achieved known strategy Adam advance give algorithm compute strategy Eve ensure minimal regret adversary whose choice strategy unrestricted limited positional strategy limited word strategy show two last case natural modelling application These result apply quantitative game defined classical payoff function \mathsf Inf \mathsf Sup \mathsf LimInf \mathsf LimSup mean-payoff also show notion regret minimization Adam limited word strategy generalizes notion good game introduced Henzinger Piterman related notion determinization pruning due Aminof Kupferman Lampert
paper introduce novel rule synthesis reactive system applicable system made n component objective rule based notion admissible strategy compare rule previous rule defined literature show contrary previous proposal defines set solution rectangular property lead solution robust resilient allows one synthesize strategy separately agent provide algorithm optimal complexity also abstraction framework compatible new rule paper introduce novel rule synthesis reactive system applicable system made n component objective rule based notion admissible strategy compare rule previous rule defined literature show contrary previous proposal defines set solution rectangular property lead solution robust resilient allows one synthesize strategy separately agent provide algorithm optimal complexity also abstraction framework compatible new rule
Quantitative game two-player zero-sum game played directed weighted graph Total-payoff games�that seen refinement well-studied mean-payoff games�are variant payoff play computed sum weight aim describe first pseudo-polynomial time algorithm total-payoff game presence arbitrary weight It consists non-trivial application value iteration paradigm Indeed requires study milestone refinement game called min-cost reachability game add reachability objective one player For game give efficient value iteration algorithm compute value optimal strategy exist run pseudo-polynomial time also propose heuristic speed computation Quantitative game two-player zero-sum game played directed weighted graph Total-payoff games�that seen refinement well-studied mean-payoff games�are variant payoff play computed sum weight aim describe first pseudo-polynomial time algorithm total-payoff game presence arbitrary weight It consists non-trivial application value iteration paradigm Indeed requires study milestone refinement game called min-cost reachability game add reachability objective one player For game give efficient value iteration algorithm compute value optimal strategy exist run pseudo-polynomial time also propose heuristic speed computation
Time representation reasoning challenging research field Computer Science recognized impact artificial intelligence database formal verification Among several formalism studied temporal reasoning two particularly interesting namely temporal logic based interval temporal network Interval-based language involved many level different application planning management medical information verification hardware circuit model-checking requirement analysis hybrid system Non-trivial problem rise every level expressive power language decidability un-decidability logic first-order modal level computational complexity automatic semi-automatic deduction technique axiomatic system Similarly various kind temporal network proposed literature including temporal constraint network simple temporal network also uncertainty preference probability disjunctive temporal network conditional temporal network For kind network different notion consistency and/or controllability defined algorithm determining whether network desired property presented Some algorithm proven polynomial others exponential Algorithms managing execution various kind temporal network also proposed Time representation reasoning challenging research field Computer Science recognized impact artificial intelligence database formal verification Among several formalism studied temporal reasoning two particularly interesting namely temporal logic based interval temporal network Interval-based language involved many level different application planning management medical information verification hardware circuit model-checking requirement analysis hybrid system Non-trivial problem rise every level expressive power language decidability un-decidability logic first-order modal level computational complexity automatic semi-automatic deduction technique axiomatic system Similarly various kind temporal network proposed literature including temporal constraint network simple temporal network also uncertainty preference probability disjunctive temporal network conditional temporal network For kind network different notion consistency and/or controllability defined algorithm determining whether network desired property presented Some algorithm proven polynomial others exponential Algorithms managing execution various kind temporal network also proposed
propositional interval logic temporal neighborhood PNL short feature two modality make possible access interval adjacent right modality \langle \rangle left modality \langle \overline \rangle current interval PNL stand central position realm interval temporal logic expressive enough encode meaningful temporal condition decidable undecidability rule interval temporal logic PNL NEXPTIME-complete Moreover expressively complete respect two-variable fragment first-order logic extended linear order \text FO ^2 [ < ] Various extension PNL studied literature including metric hybrid first-order one Here study effect addition equivalence relation \sim Metric PNL MPNL\ \sim first show finite satisfiability problem PNL extended \sim still NEXPTIME-complete Then prove problem MPNL\ \sim reduced decidable 0�0 reachability problem vector addition system vice versa EXPSPACE-hardness immediately follows propositional interval logic temporal neighborhood PNL short feature two modality make possible access interval adjacent right modality \langle \rangle left modality \langle \overline \rangle current interval PNL stand central position realm interval temporal logic expressive enough encode meaningful temporal condition decidable undecidability rule interval temporal logic PNL NEXPTIME-complete Moreover expressively complete respect two-variable fragment first-order logic extended linear order \text FO ^2 [ < ] Various extension PNL studied literature including metric hybrid first-order one Here study effect addition equivalence relation \sim Metric PNL MPNL\ \sim first show finite satisfiability problem PNL extended \sim still NEXPTIME-complete Then prove problem MPNL\ \sim reduced decidable 0�0 reachability problem vector addition system vice versa EXPSPACE-hardness immediately follows
Planning real world problem explicit temporal constraint challenging problem Among several approach use flexible timeline Planning Scheduling shown successful number concrete application instance autonomous space system paper build previous work present revised extended formal account flexible timeline aim providing general semantics related planning concept domain goal problem constraint flexible plan Some source uncertainty also modeled proposed framework taken account characterization valid plan assumed take decision component planner control formal definition different form plan controllability also proposed Planning real world problem explicit temporal constraint challenging problem Among several approach use flexible timeline Planning Scheduling shown successful number concrete application instance autonomous space system paper build previous work present revised extended formal account flexible timeline aim providing general semantics related planning concept domain goal problem constraint flexible plan Some source uncertainty also modeled proposed framework taken account characterization valid plan assumed take decision component planner control formal definition different form plan controllability also proposed
Model checking powerful method widely explored formal verification Given model system Kripke structure formula specifying expected behaviour one verify whether system meet behaviour checking formula model Classically system behaviour expressed formula temporal logic LTL like These logic � point-wise � interpreted describe system evolves state-by-state However relevant property constraining temporal relation pair temporally extended event involving temporal aggregation inherently � interval-based � thus asking interval temporal logic paper give formalization model checking problem interval logic setting First provide interpretation formula Halpern Shoham � interval temporal logic HS finite Kripke structure allows one check interval property computation Then prove model checking problem HS finite Kripke structure decidable suitable small model theorem provide lower bound computational complexity Model checking powerful method widely explored formal verification Given model system Kripke structure formula specifying expected behaviour one verify whether system meet behaviour checking formula model Classically system behaviour expressed formula temporal logic LTL like These logic � point-wise � interpreted describe system evolves state-by-state However relevant property constraining temporal relation pair temporally extended event involving temporal aggregation inherently � interval-based � thus asking interval temporal logic paper give formalization model checking problem interval logic setting First provide interpretation formula Halpern Shoham � interval temporal logic HS finite Kripke structure allows one check interval property computation Then prove model checking problem HS finite Kripke structure decidable suitable small model theorem provide lower bound computational complexity
Temporal network data structure representing reasoning temporal constraint activity Many kind temporal network defined literature differing expressiveness simplest kind network polynomial algorithm determining temporal consistency different level controllability corresponding algorithm expressive network include observation node disjunctive constraint far unavailable paper introduces new approach determine dynamic controllability expressive class temporal network accommodates observation node disjunctive constraint approach based encoding dynamic controllability problem reachability game Timed Game Automata TGAs first sound complete approach determining dynamic controllability network encoding also highlight theoretical relationship various kind temporal network TGAs new algorithm immediate application design analysis workflow model developed automate business process including workflow health-care domain Temporal network data structure representing reasoning temporal constraint activity Many kind temporal network defined literature differing expressiveness simplest kind network polynomial algorithm determining temporal consistency different level controllability corresponding algorithm expressive network include observation node disjunctive constraint far unavailable paper introduces new approach determine dynamic controllability expressive class temporal network accommodates observation node disjunctive constraint approach based encoding dynamic controllability problem reachability game Timed Game Automata TGAs first sound complete approach determining dynamic controllability network encoding also highlight theoretical relationship various kind temporal network TGAs new algorithm immediate application design analysis workflow model developed automate business process including workflow health-care domain
Temporal functional dependency add valid time classical functional dependency order express data integrity constraint flow time If temporal dimension adopted interval deal interval-based temporal functional dependency ITFDs short consider different interval relation tuple valid time related approximate problem want check whether data satisfy without constraint schema given ITFD given error threshold \leqslant \epsilon \leqslant 1\ rephrased given relation instance r possible delete \epsilon \cdot |r|\ tuples way resulting instance satisfies given ITFD ? optimization problem ITFD-Approx short may represent way discover i.e mine important dependency among attribute value database paper analyze complexity problem ITFD-Approx restricting Allen � interval relation shall see complexity problem may significantly change depending considered interval relation Temporal functional dependency add valid time classical functional dependency order express data integrity constraint flow time If temporal dimension adopted interval deal interval-based temporal functional dependency ITFDs short consider different interval relation tuple valid time related approximate problem want check whether data satisfy without constraint schema given ITFD given error threshold \leqslant \epsilon \leqslant 1\ rephrased given relation instance r possible delete \epsilon \cdot |r|\ tuples way resulting instance satisfies given ITFD ? optimization problem ITFD-Approx short may represent way discover i.e mine important dependency among attribute value database paper analyze complexity problem ITFD-Approx restricting Allen � interval relation shall see complexity problem may significantly change depending considered interval relation
Temporal formalism essential reasoning action carried time exact duration action generally hard predict temporal planning resulting uncertainty often worked around considering upper bound duration assumption action happens executed quickly plan still succeed However assumption often false finish cooking early dinner cold everyone ready eat Using simple temporal network uncertainty STNU planner correctly take lower upper duration bound account It must verify plan generates executable regardless actual outcome uncertain duration captured property dynamic controllability DC verified incrementally plan generation Recently new incremental algorithm verifying dynamic controllability proposed EfficientIDC verify STNU DC remains DC addition tightening constraint corresponding new action added plan algorithm shown worst case complexity O n^4 addition tightening amortized construction whole STNU amortized complexity O n^3 paper improve EfficientIDC algorithm way prevents reprocess node improvement lead lower worst case complexity O n^3 Temporal formalism essential reasoning action carried time exact duration action generally hard predict temporal planning resulting uncertainty often worked around considering upper bound duration assumption action happens executed quickly plan still succeed However assumption often false finish cooking early dinner cold everyone ready eat Using simple temporal network uncertainty STNU planner correctly take lower upper duration bound account It must verify plan generates executable regardless actual outcome uncertain duration captured property dynamic controllability DC verified incrementally plan generation Recently new incremental algorithm verifying dynamic controllability proposed EfficientIDC verify STNU DC remains DC addition tightening constraint corresponding new action added plan algorithm shown worst case complexity O n^4 addition tightening amortized construction whole STNU amortized complexity O n^3 paper improve EfficientIDC algorithm way prevents reprocess node improvement lead lower worst case complexity O n^3
concurrent Abstract State Machine ASM family agent equipped sequential ASM execute define semantics concurrent ASMs concurrent ASM run overcome problem Gurevich � distributed ASM run generalize Lamport � sequentially consistent run postulate characterizing intuitive understanding concurrency formulated It allows u state prove extension sequential ASM thesis concurrent ASM thesis concurrent Abstract State Machine ASM family agent equipped sequential ASM execute define semantics concurrent ASMs concurrent ASM run overcome problem Gurevich � distributed ASM run generalize Lamport � sequentially consistent run postulate characterizing intuitive understanding concurrency formulated It allows u state prove extension sequential ASM thesis concurrent ASM thesis
problem finding optimal cover possible fewest attribute NP-complete It shown optimal cover found using notion mini cover minimum Boolean expression first Delobel�Casey transform set functional dependency converted corresponding mini cover refining classic canonical cover relationship optimal cover Boolean expression minimization built theory Boolean expression minimization used find optimal cover problem finding optimal cover possible fewest attribute NP-complete It shown optimal cover found using notion mini cover minimum Boolean expression first Delobel�Casey transform set functional dependency converted corresponding mini cover refining classic canonical cover relationship optimal cover Boolean expression minimization built theory Boolean expression minimization used find optimal cover
provide treatment reversible Turing machine RTMs strict function semantics Unlike many existing reversible computation model distinguish strictly computing function \lambda x.f x computing function \lambda x x f x injective embeddings f. reinterpret adapt number important foundational reversible computing result semantics Unifying result single model show expected previously claimed RTMs robust compute exactly injective computable function Because injectivity entail RTMs strictly Turing-complete w.r.t function use appropriate alternative universality definition show derive universal RTMs URTMs existing irreversible universal machine proceed construct URTM ground resulting machine first URTM depend reversible simulation existing universal machine new construction advantage interpretive overhead URTM limited program dependent constant factor Another novelty URTM function inverse interpreter asymptotic cost provide treatment reversible Turing machine RTMs strict function semantics Unlike many existing reversible computation model distinguish strictly computing function \lambda x.f x computing function \lambda x x f x injective embeddings f. reinterpret adapt number important foundational reversible computing result semantics Unifying result single model show expected previously claimed RTMs robust compute exactly injective computable function Because injectivity entail RTMs strictly Turing-complete w.r.t function use appropriate alternative universality definition show derive universal RTMs URTMs existing irreversible universal machine proceed construct URTM ground resulting machine first URTM depend reversible simulation existing universal machine new construction advantage interpretive overhead URTM limited program dependent constant factor Another novelty URTM function inverse interpreter asymptotic cost
orbit problem heart symmetry reduction method model checking concurrent system It asks whether two given configuration concurrent system represented finite string finite alphabet orbit respect given finite permutation group represented generator acting set configuration permuting index It known problem general hard graph isomorphism problem whose precise complexity whether solvable polynomial-time long-standing open problem paper consider restriction orbit problem permutation group cyclic i.e generated single permutation important restriction problem It known subproblem solvable polynomial-time main result linear-time algorithm subproblem orbit problem heart symmetry reduction method model checking concurrent system It asks whether two given configuration concurrent system represented finite string finite alphabet orbit respect given finite permutation group represented generator acting set configuration permuting index It known problem general hard graph isomorphism problem whose precise complexity whether solvable polynomial-time long-standing open problem paper consider restriction orbit problem permutation group cyclic i.e generated single permutation important restriction problem It known subproblem solvable polynomial-time main result linear-time algorithm subproblem
main goal Rich Model Toolkit initiative explore direction technique making automated reasoning including analysis synthesis applicable wider range problem well making easier use researcher software developer hardware designer information system user developer Rich Model Toolkit funded European Union COST Action IC0901 2009 2013 main goal Rich Model Toolkit initiative explore direction technique making automated reasoning including analysis synthesis applicable wider range problem well making easier use researcher software developer hardware designer information system user developer Rich Model Toolkit funded European Union COST Action IC0901 2009 2013
Craig interpolation standard method construct refine abstraction model checking obtain abstraction suitable verification software program hardware design model checker rely theorem provers find right interpolants interpolants containing right predicate generally infinite lattice interpolants given interpolation problem present semantic solver-independent framework systematically exploring interpolant lattice based notion interpolation abstraction discus interpolation abstraction constructed variety logic applied context software model checking Craig interpolation standard method construct refine abstraction model checking obtain abstraction suitable verification software program hardware design model checker rely theorem provers find right interpolants interpolants containing right predicate generally infinite lattice interpolants given interpolation problem present semantic solver-independent framework systematically exploring interpolant lattice based notion interpolation abstraction discus interpolation abstraction constructed variety logic applied context software model checking
Analysis massive codebases � big code � present opportunity drawing insight programming practice enabling code reuse One main challenge analyzing big code finding representation capture sufficient semantic information constructed efficiently amenable meaningful comparison operation present formal framework representing code large codebases framework semantic descriptor code snippet partial temporal specification capture sequence method invocation API main idea represent partial temporal specification symbolic automata�automata transition may labeled variable variable substituted letter word regular language Using symbolic automaton construct abstract domain static analysis big code capturing partialness specification precision specification show interesting relationship lattice operation domain common operator manipulating partial temporal specification building informative specification consolidating two partial specification comparing partial temporal specification Analysis massive codebases � big code � present opportunity drawing insight programming practice enabling code reuse One main challenge analyzing big code finding representation capture sufficient semantic information constructed efficiently amenable meaningful comparison operation present formal framework representing code large codebases framework semantic descriptor code snippet partial temporal specification capture sequence method invocation API main idea represent partial temporal specification symbolic automata�automata transition may labeled variable variable substituted letter word regular language Using symbolic automaton construct abstract domain static analysis big code capturing partialness specification precision specification show interesting relationship lattice operation domain common operator manipulating partial temporal specification building informative specification consolidating two partial specification comparing partial temporal specification
present formalism algorithm tool synthesise reactive system behave efficiently i.e achieve optimal trade-off given cost reward model Synthesis aim automatically generate program specification Most research area focus qualitative specification i.e define system either correct incorrect result system correct still show undesired behaviour slow inefficient resource-intensive Quantitative synthesis aim use additional information guide synthesizer towards desired implementation Trade-offs cost reward provide natural source information order guarantee efficiency system want synthesize open i.e react input signal environment So specify combine trade-off system decides make input There several possible way worst best case average case paper focus average case i.e focus expected trade-off achieved system define problem finding system best expected behaviour according quantitative specification specification associate cost reward decision system make defines probabilistic environment system operates analyze feasibility task i.e prove system exist computable present three algorithm compute optimal system given specification compare prototypical implementation algorithm based best-performing algorithm develop novel symbolic implementation integrate probabilistic model checker PRISM report experiment showing algorithm analyze model several million state present formalism algorithm tool synthesise reactive system behave efficiently i.e achieve optimal trade-off given cost reward model Synthesis aim automatically generate program specification Most research area focus qualitative specification i.e define system either correct incorrect result system correct still show undesired behaviour slow inefficient resource-intensive Quantitative synthesis aim use additional information guide synthesizer towards desired implementation Trade-offs cost reward provide natural source information order guarantee efficiency system want synthesize open i.e react input signal environment So specify combine trade-off system decides make input There several possible way worst best case average case paper focus average case i.e focus expected trade-off achieved system define problem finding system best expected behaviour according quantitative specification specification associate cost reward decision system make defines probabilistic environment system operates analyze feasibility task i.e prove system exist computable present three algorithm compute optimal system given specification compare prototypical implementation algorithm based best-performing algorithm develop novel symbolic implementation integrate probabilistic model checker PRISM report experiment showing algorithm analyze model several million state
present general framework verifying program complex dynamic linked data structure whose correctness depends ordering relation stored data value underlying formalism framework forest automaton FA previously developed verification heap-manipulating program extend FA constraint data element associated node heap represented FA present extended version operation needed using extended FA fully-automated verification approach based abstract interpretation implemented approach extension Forester tool successfully applied number program dealing data structure various form singly- doubly-linked list binary search tree well skip list present general framework verifying program complex dynamic linked data structure whose correctness depends ordering relation stored data value underlying formalism framework forest automaton FA previously developed verification heap-manipulating program extend FA constraint data element associated node heap represented FA present extended version operation needed using extended FA fully-automated verification approach based abstract interpretation implemented approach extension Forester tool successfully applied number program dealing data structure various form singly- doubly-linked list binary search tree well skip list
introduce new way defining metric temporal logic continuous real model time semantics refer single universal clock order impose metric constraint desired precision Furthermore expression non-metric aspect correctly utilise full power continuous time temporal logic Syntactic construct afford convenient succinct expression many useful typical constraint including interesting requirement regular occurrence decision procedure provided via simple translation existing non-metric temporal logic give workable complexity possibility automated reasoning There advantage expressiveness naturalness generality amenability reasoning technique existing metric temporal logic Combining purely continuous adequate metric aspect one language make logic suitable dealing hybrid system introduce new way defining metric temporal logic continuous real model time semantics refer single universal clock order impose metric constraint desired precision Furthermore expression non-metric aspect correctly utilise full power continuous time temporal logic Syntactic construct afford convenient succinct expression many useful typical constraint including interesting requirement regular occurrence decision procedure provided via simple translation existing non-metric temporal logic give workable complexity possibility automated reasoning There advantage expressiveness naturalness generality amenability reasoning technique existing metric temporal logic Combining purely continuous adequate metric aspect one language make logic suitable dealing hybrid system
Interval temporal logic take time interval instead time point primitive temporal entity One studied interval temporal logic Halpern Shoham � modal logic time interval HS associate modal operator binary relation interval linear order so-called Allen � interval relation paper compare classify expressiveness fragment HS class linear order subclass dense linear order For class identify complete set definabilities HS modality valid class thus obtaining complete classification family 4096 fragment HS respect expressiveness show class linear order exactly 1347 expressively different fragment HS class dense linear order exactly 966 expressively different fragment Interval temporal logic take time interval instead time point primitive temporal entity One studied interval temporal logic Halpern Shoham � modal logic time interval HS associate modal operator binary relation interval linear order so-called Allen � interval relation paper compare classify expressiveness fragment HS class linear order subclass dense linear order For class identify complete set definabilities HS modality valid class thus obtaining complete classification family 4096 fragment HS respect expressiveness show class linear order exactly 1347 expressively different fragment HS class dense linear order exactly 966 expressively different fragment
Unsatisfiable core UCs well established mean debugging declarative setting Still tool perform automated extraction UCs LTL Existing tool compute UC unsatisfiable subset set top-level conjuncts LTL formula Using resolution graph extract UCs common domain SAT article construct optimize resolution graph temporal resolution implemented temporal resolution-based solver TRP++ use extract UCs propositional LTL resulting UCs fine-grained UCs obtained existing tool UC extraction also simplifies top-level conjuncts instead treating atomic entity For example given unsatisfiable LTL formula form \phi \equiv \mathbf G \psi \wedge \mathbf F \psi ' existing tool return \phi UC irrespective complexity \psi \psi ' whereas approach presented article continues remove part required unsatisfiability inside \psi \psi ' approach also identifies group occurrence proposition interact proof unsatisfiability implement approach TRP++ experimental evaluation demonstrates approach extract UCs often significantly smaller input formula acceptable overhead ii produce fine-grained UCs competing tool remaining least competitive term run time memory usage source code tool publicly available Unsatisfiable core UCs well established mean debugging declarative setting Still tool perform automated extraction UCs LTL Existing tool compute UC unsatisfiable subset set top-level conjuncts LTL formula Using resolution graph extract UCs common domain SAT article construct optimize resolution graph temporal resolution implemented temporal resolution-based solver TRP++ use extract UCs propositional LTL resulting UCs fine-grained UCs obtained existing tool UC extraction also simplifies top-level conjuncts instead treating atomic entity For example given unsatisfiable LTL formula form \phi \equiv \mathbf G \psi \wedge \mathbf F \psi ' existing tool return \phi UC irrespective complexity \psi \psi ' whereas approach presented article continues remove part required unsatisfiability inside \psi \psi ' approach also identifies group occurrence proposition interact proof unsatisfiability implement approach TRP++ experimental evaluation demonstrates approach extract UCs often significantly smaller input formula acceptable overhead ii produce fine-grained UCs competing tool remaining least competitive term run time memory usage source code tool publicly available
September 2013 organized 20th International Symposium Temporal Representation Reasoning TIME � 13 took place Pensacola FL USA After 20 year Symposium returned venue originally started TIME grown since original incarnation workshop become international symposium encompassing several different area computer science deal way another concept time representation reasoning application event provided opportunity scientific exchange researcher coming different area artificial intelligence database temporal logic formal method work presented 2013 Symposium concerned several different temporal aspect information computation comprises unique combination innovative theoretical result successful application September 2013 organized 20th International Symposium Temporal Representation Reasoning TIME � 13 took place Pensacola FL USA After 20 year Symposium returned venue originally started TIME grown since original incarnation workshop become international symposium encompassing several different area computer science deal way another concept time representation reasoning application event provided opportunity scientific exchange researcher coming different area artificial intelligence database temporal logic formal method work presented 2013 Symposium concerned several different temporal aspect information computation comprises unique combination innovative theoretical result successful application
Constraint LTL clock variant CLTL extension linear-time temporal logic allowing atomic assertion concrete constraint system Satisfiability CLTL clock shown decidable mean reduction decidable Satisfiability Modulo Theories SMT problem result complete Bounded Satisfiability Checking procedure implemented using standard SMT solver importance technique derives possibility translating various continuous-time metric temporal logic MITL QTL CLTL clock Although standard decision procedure logic exist never realized practice Suitable translation CLTL clock instead allowed u development first prototype tool deciding MITL QTL paper also report preliminary encouraging experiment significant example MITL QTL formula Constraint LTL clock variant CLTL extension linear-time temporal logic allowing atomic assertion concrete constraint system Satisfiability CLTL clock shown decidable mean reduction decidable Satisfiability Modulo Theories SMT problem result complete Bounded Satisfiability Checking procedure implemented using standard SMT solver importance technique derives possibility translating various continuous-time metric temporal logic MITL QTL CLTL clock Although standard decision procedure logic exist never realized practice Suitable translation CLTL clock instead allowed u development first prototype tool deciding MITL QTL paper also report preliminary encouraging experiment significant example MITL QTL formula
simple temporal network uncertainty STNU data structure representing reasoning temporal constraint duration certain temporal intervals�the contingent links�are discovered execution important property STNU whether dynamically controllable DC �that whether exists strategy executing time-points guarantee constraint satisfied matter duration contingent link turn literature STNUs includes variety DC-checking algorithm execution algorithm fastest DC-checking algorithm reported far O N^3 -time algorithm due Morris Integration AI OR technique constraint programming�11th international conference CPAIOR 2014 volume 8451 Lecture Notes Computer Science Springer Berlin pp 464�479 2014 fastest execution algorithm dynamically controllable STNUs O N^3 -time algorithm due Hunsberger Proceedings 20th international symposium temporal representation reasoning TIME-2013 IEEE Computer Society Washington 2013 paper begin providing first comprehensive rigorous yet streamlined treatment theoretical foundation STNUs including execution semantics dynamic controllability set result collected recently called fundamental theorem STNUs paper carefully argues basic definition proof major theorem important algorithmic work STNUs depends Although many part presentation appeared various form various paper scattered nature STNU literature allowed many hole theory persist relied often proof sketch leave important detail unexamined presentation combine result many source also introducing novel approach proof paper concludes presenting modified version recent algorithm managing execution dynamically controllable STNUs fastest reported far literature modified version organizes computation efficiently corrects oversight original algorithm simple temporal network uncertainty STNU data structure representing reasoning temporal constraint duration certain temporal intervals�the contingent links�are discovered execution important property STNU whether dynamically controllable DC �that whether exists strategy executing time-points guarantee constraint satisfied matter duration contingent link turn literature STNUs includes variety DC-checking algorithm execution algorithm fastest DC-checking algorithm reported far O N^3 -time algorithm due Morris Integration AI OR technique constraint programming�11th international conference CPAIOR 2014 volume 8451 Lecture Notes Computer Science Springer Berlin pp 464�479 2014 fastest execution algorithm dynamically controllable STNUs O N^3 -time algorithm due Hunsberger Proceedings 20th international symposium temporal representation reasoning TIME-2013 IEEE Computer Society Washington 2013 paper begin providing first comprehensive rigorous yet streamlined treatment theoretical foundation STNUs including execution semantics dynamic controllability set result collected recently called fundamental theorem STNUs paper carefully argues basic definition proof major theorem important algorithmic work STNUs depends Although many part presentation appeared various form various paper scattered nature STNU literature allowed many hole theory persist relied often proof sketch leave important detail unexamined presentation combine result many source also introducing novel approach proof paper concludes presenting modified version recent algorithm managing execution dynamically controllable STNUs fastest reported far literature modified version organizes computation efficiently corrects oversight original algorithm
Various formalism representing reasoning temporal information qualitative constraint studied past three decade known definitely Point Algebra \mathsf PA Interval Algebra \mathsf IA proposed Allen paper calculus study problem call minimal consistency problem \mathsf MinCons Given temporal qualitative constraint network \mathsf TQCN positive integer k\ problem consists deciding whether \mathsf TQCN admits solution using k\ distinct point line.We show \mathsf MinCons \mathsf PA encoded finitary version G�del logic Furthermore prove \mathsf MinCons problem \mathsf NP -complete \mathsf PA \mathsf IA general case However show \mathsf TQCN defined convex relation \mathsf MinCons polynomial For \mathsf TQCN give polynomial method allows one obtain compact scenario Various formalism representing reasoning temporal information qualitative constraint studied past three decade known definitely Point Algebra \mathsf PA Interval Algebra \mathsf IA proposed Allen paper calculus study problem call minimal consistency problem \mathsf MinCons Given temporal qualitative constraint network \mathsf TQCN positive integer k\ problem consists deciding whether \mathsf TQCN admits solution using k\ distinct point line.We show \mathsf MinCons \mathsf PA encoded finitary version G�del logic Furthermore prove \mathsf MinCons problem \mathsf NP -complete \mathsf PA \mathsf IA general case However show \mathsf TQCN defined convex relation \mathsf MinCons polynomial For \mathsf TQCN give polynomial method allows one obtain compact scenario
notion k\ -comma code k\ -comma intercodes proper generalization comma-free code intercodes respectively paper characterize k\ -comma code k\ -comma intercodes using infix code bifix code Then consider homomorphism preserve k\ -comma code k\ -comma intercodes notion k\ -comma code k\ -comma intercodes proper generalization comma-free code intercodes respectively paper characterize k\ -comma code k\ -comma intercodes using infix code bifix code Then consider homomorphism preserve k\ -comma code k\ -comma intercodes
It well known language obtained deleting arbitrary language regular language regular give upper bound state complexity deleting arbitrary language regular language matching lower bound show state complexity deletion n \cdot 2^ n-1 [ respectively n \frac \cdot 2^n - 2\ ] using complete respectively incomplete deterministic finite automaton show state complexity bipolar deletion upper bound n^n\ [ respectively n+1 ^n - 1\ ] using complete respectively incomplete deterministic finite automaton case give almost matching lower bound It well known language obtained deleting arbitrary language regular language regular give upper bound state complexity deleting arbitrary language regular language matching lower bound show state complexity deletion n \cdot 2^ n-1 [ respectively n \frac \cdot 2^n - 2\ ] using complete respectively incomplete deterministic finite automaton show state complexity bipolar deletion upper bound n^n\ [ respectively n+1 ^n - 1\ ] using complete respectively incomplete deterministic finite automaton case give almost matching lower bound
dual-hop truncated ARQ DHT-ARQ multiple relay cooperative truncated ARQ MRCT-ARQ relay selection wireless sensor network analytically analyzed paper three-state discrete time Markov chain method proposed used derive steady state distribution throughput expression Furthermore number retransmission two protocol truncated average packet transmission delay solved Finally considering power consumption source node relay node destination node energy efficiency expression obtained Numerical simulation result show throughput delay performance latter better former When channel environment becomes poor using DHT-ARQ protocol advantageous reduce system overhead dual-hop truncated ARQ DHT-ARQ multiple relay cooperative truncated ARQ MRCT-ARQ relay selection wireless sensor network analytically analyzed paper three-state discrete time Markov chain method proposed used derive steady state distribution throughput expression Furthermore number retransmission two protocol truncated average packet transmission delay solved Finally considering power consumption source node relay node destination node energy efficiency expression obtained Numerical simulation result show throughput delay performance latter better former When channel environment becomes poor using DHT-ARQ protocol advantageous reduce system overhead
classical Mazurkiewicz trace approach behaviour concurrent system described term sequential observation differ respect ordering independent action paper investigates extension trace model case action observed occurring simultaneously Thus observation sequence step i.e set action lead step trace model based three relation event simultaneity serialisability interleaving Whereas underlying causal structure trace based dependency action leading partial order interpretation general causal structure needed describe invariant relationship action occurrence step trace present complete picture including dependence structure extending dependence graph characterisation step trace term invariant order structure classical Mazurkiewicz trace approach behaviour concurrent system described term sequential observation differ respect ordering independent action paper investigates extension trace model case action observed occurring simultaneously Thus observation sequence step i.e set action lead step trace model based three relation event simultaneity serialisability interleaving Whereas underlying causal structure trace based dependency action leading partial order interpretation general causal structure needed describe invariant relationship action occurrence step trace present complete picture including dependence structure extending dependence graph characterisation step trace term invariant order structure
ordered restarting automaton processing string introduced shown nondeterministic variant expressive accepts language even context-free deterministic ordered restarting automaton accept regular language Then three different extension deterministic ordered restarting automaton two-dimensional input defined differ way move read/write window compare class picture language type automaton accept well studied class picture language literature present closure non-closure property ordered restarting automaton processing string introduced shown nondeterministic variant expressive accepts language even context-free deterministic ordered restarting automaton accept regular language Then three different extension deterministic ordered restarting automaton two-dimensional input defined differ way move read/write window compare class picture language type automaton accept well studied class picture language literature present closure non-closure property
Two-way finite state transducer considered use finite number pebble life time must nested For every nondeterministic transducer realizes partial function equivalent deterministic transducer constructed composition two deterministic transducer realized one transducer minimal number pebble Two-way finite state transducer considered use finite number pebble life time must nested For every nondeterministic transducer realizes partial function equivalent deterministic transducer constructed composition two deterministic transducer realized one transducer minimal number pebble
Based order relation inspired binary reflected Gray code BRGC define Gray code give generating algorithm q\ -ary word avoiding prescribed factor These generalize early 2001 result recent one published present author seen alternative Squire published 1996 Among involved tool make use generalized BRGC order relation ultimate periodicity infinite word word matching technique Based order relation inspired binary reflected Gray code BRGC define Gray code give generating algorithm q\ -ary word avoiding prescribed factor These generalize early 2001 result recent one published present author seen alternative Squire published 1996 Among involved tool make use generalized BRGC order relation ultimate periodicity infinite word word matching technique
study uniform verification problem infinite state process problem consists proving parallel composition arbitrary number process running program finite collection program satisfies temporal property practical motivation build general framework temporal verification concurrent datatypes paper propose general method verification safety property parametrized program manipulate complex local global data including mutable state heap method based clear division following two dimension problem interaction executing threads�handled novel parametrized invariance proof rule data manipulated�handled specialized decision procedure proof rule discharge automatically finite collection verification condition size collection depends size program specification number process given instance kind data manipulated Moreover verification condition quantifier free eas development decision procedure complex data-types top off-the-shelf SMT solver prove soundness proof rule illustrate application formal verification two infinite-state mutual exclusion protocol shape functional correctness property several concurrent data-types including fine-grained non-blocking concurrent list queue report empirical result using prototype implementation proof rule decision procedure study uniform verification problem infinite state process problem consists proving parallel composition arbitrary number process running program finite collection program satisfies temporal property practical motivation build general framework temporal verification concurrent datatypes paper propose general method verification safety property parametrized program manipulate complex local global data including mutable state heap method based clear division following two dimension problem interaction executing threads�handled novel parametrized invariance proof rule data manipulated�handled specialized decision procedure proof rule discharge automatically finite collection verification condition size collection depends size program specification number process given instance kind data manipulated Moreover verification condition quantifier free eas development decision procedure complex data-types top off-the-shelf SMT solver prove soundness proof rule illustrate application formal verification two infinite-state mutual exclusion protocol shape functional correctness property several concurrent data-types including fine-grained non-blocking concurrent list queue report empirical result using prototype implementation proof rule decision procedure
paper aim investigate property involution binary relation particular binary relation study concept involution spanning set give example related different involution binary relation Moreover relationship among involution independent set code involution code studied mapping function either morphic antimorphic involution X^*\ paper aim investigate property involution binary relation particular binary relation study concept involution spanning set give example related different involution binary relation Moreover relationship among involution independent set code involution code studied mapping function either morphic antimorphic involution X^*\
Contextual hyperedge-replacement grammar contextual grammar short extension hyperedge replacement grammar They recently proposed grammatical method capturing structure object-oriented program thus serving alternative use meta-models like uml class diagram model-driven software design paper study property contextual grammar Even though grammar context-free one show inherit several nice property hyperedge replacement grammar particular posse useful normal form membership problem NP Contextual hyperedge-replacement grammar contextual grammar short extension hyperedge replacement grammar They recently proposed grammatical method capturing structure object-oriented program thus serving alternative use meta-models like uml class diagram model-driven software design paper study property contextual grammar Even though grammar context-free one show inherit several nice property hyperedge replacement grammar particular posse useful normal form membership problem NP
second part special issue motivated workshop � 25 Years Combining Compositionality Concurrency � organised August 2013 K�nigswinter near Bonn Germany first part published Acta Informatica 2015 52 :3�106 For introduction topic see editorial second part comprises four paper second part special issue motivated workshop � 25 Years Combining Compositionality Concurrency � organised August 2013 K�nigswinter near Bonn Germany first part published Acta Informatica 2015 52 :3�106 For introduction topic see editorial second part comprises four paper
On Thursday 26th April 2015 Friedrich L. Bauer Professor emeritus Faculty Informatics Technischen Universit�t M�nchen passed away age 90 following prolonged illness Informatics Germany loos one influential pioneer With contribution Friedrich L. Bauer decisively influenced several stage development discipline shaped world like last 50 year On Thursday 26th April 2015 Friedrich L. Bauer Professor emeritus Faculty Informatics Technischen Universit�t M�nchen passed away age 90 following prolonged illness Informatics Germany loos one influential pioneer With contribution Friedrich L. Bauer decisively influenced several stage development discipline shaped world like last 50 year
During last decade concurrency theory successfully developed salient concept formally model soundly reason distributed parallel system practice however attempt analyzing large system face severe complexity issue especially state explosion prevents exhaustively enumerate reachable state space Compositionality promising approach fight state explosion article focus finite-state verification technique asynchronous message-passing system highlighting existence multiple diverse compositional technique compositional model generation semi-composition projection automatic generation projection interface formula-dependent model generation partial model checking These approach implemented framework CADP Construction Analysis Distributed Processes software toolbox applied large-scale industrial system key point ability combine several compositional technique single technique sufficient address kind system During last decade concurrency theory successfully developed salient concept formally model soundly reason distributed parallel system practice however attempt analyzing large system face severe complexity issue especially state explosion prevents exhaustively enumerate reachable state space Compositionality promising approach fight state explosion article focus finite-state verification technique asynchronous message-passing system highlighting existence multiple diverse compositional technique compositional model generation semi-composition projection automatic generation projection interface formula-dependent model generation partial model checking These approach implemented framework CADP Construction Analysis Distributed Processes software toolbox applied large-scale industrial system key point ability combine several compositional technique single technique sufficient address kind system
Given system \fancyscript objective \varPhi task controller synthesis design decision making policy ensures \varPhi satisfied article deal transition system-like system model controller base decision observables action performed far present framework compositional construction controller conjunctive sequence linear-time objective online manner For approach crucial controller enforce objective general manner permissive possible present game-based algorithm construction general controller invariance reachability \omega -regular objective Given system \fancyscript objective \varPhi task controller synthesis design decision making policy ensures \varPhi satisfied article deal transition system-like system model controller base decision observables action performed far present framework compositional construction controller conjunctive sequence linear-time objective online manner For approach crucial controller enforce objective general manner permissive possible present game-based algorithm construction general controller invariance reachability \omega -regular objective
synchronous model concurrent computation SMoCC well established programming language domain safety-critical reactive embedded system Translated mainstream C/Java programming SMoCC corresponds cyclic execution model concurrent thread synchronised logical clock cut system computation sequence macro-steps causality analysis verifies existence schedule memory access ensure macro-step deadlock-free determinate introduce abstract semantic domain I \mathbb D \mathbb P associated denotational fixed-point semantics reasoning concurrent sequential variable access within synchronous cycle-based model computation use domain new extended behavioural definition Berry � causality analysis term approximation interval domain I \mathbb D \mathbb P extends domain I \mathbb D previous work fix mistake treatment initialisation Based fixed-point semantics propose notion Input Berry-constructiveness IBC synchronous program new IBC class lie properly strong SBC normal Berry-constructiveness BC defined previous work SBC BC two way interpret standard constructive semantics synchronous programming exemplified imperative SMoCC language Esterel Quartz SBC often restrictive requires variable initialised program BC permissive initialises variable fixed value default Where initialisation happens memory carrying value one synchronous tick next IBC appropriate IBC link two level execution macro-step level micro-step level prove denotational fixed-point analysis IBC hence Berry � causality analysis sound respect operational micro-level scheduling denotational model thus viewed compositional presentation synchronous scheduling strategy ensures reactiveness determinacy imperative concurrent programming synchronous model concurrent computation SMoCC well established programming language domain safety-critical reactive embedded system Translated mainstream C/Java programming SMoCC corresponds cyclic execution model concurrent thread synchronised logical clock cut system computation sequence macro-steps causality analysis verifies existence schedule memory access ensure macro-step deadlock-free determinate introduce abstract semantic domain I \mathbb D \mathbb P associated denotational fixed-point semantics reasoning concurrent sequential variable access within synchronous cycle-based model computation use domain new extended behavioural definition Berry � causality analysis term approximation interval domain I \mathbb D \mathbb P extends domain I \mathbb D previous work fix mistake treatment initialisation Based fixed-point semantics propose notion Input Berry-constructiveness IBC synchronous program new IBC class lie properly strong SBC normal Berry-constructiveness BC defined previous work SBC BC two way interpret standard constructive semantics synchronous programming exemplified imperative SMoCC language Esterel Quartz SBC often restrictive requires variable initialised program BC permissive initialises variable fixed value default Where initialisation happens memory carrying value one synchronous tick next IBC appropriate IBC link two level execution macro-step level micro-step level prove denotational fixed-point analysis IBC hence Berry � causality analysis sound respect operational micro-level scheduling denotational model thus viewed compositional presentation synchronous scheduling strategy ensures reactiveness determinacy imperative concurrent programming
Modal transition system popular semantic underpinning interface theory Nyman et al. � IOMTS Bauer et al. � MIO facilitate component-based reasoning concurrent system interface theory MIA repaired compositional flaw IOMTS-refinement introduced conjunction operator paper first modify MIA properly deal internal computation including internal must-transitions largely ignored already IOMTS study MIA variant adopts MIO � pessimistic�rather IOMTS � optimistic�view component compatibility define first-time pessimistic non-deterministic setting conjunction disjunction interface For optimistic pessimistic MIA variant also discus mechanism extending alphabet refining interface desired feature perspective-based specification illustrate advancement via small example Modal transition system popular semantic underpinning interface theory Nyman et al. � IOMTS Bauer et al. � MIO facilitate component-based reasoning concurrent system interface theory MIA repaired compositional flaw IOMTS-refinement introduced conjunction operator paper first modify MIA properly deal internal computation including internal must-transitions largely ignored already IOMTS study MIA variant adopts MIO � pessimistic�rather IOMTS � optimistic�view component compatibility define first-time pessimistic non-deterministic setting conjunction disjunction interface For optimistic pessimistic MIA variant also discus mechanism extending alphabet refining interface desired feature perspective-based specification illustrate advancement via small example
feel privileged serve guest editor special issue Acta Informatica honour colleague friend Walter Vogler occasion 60th birthday Walter � high scientific standard many publication Acta Informatica make journal fitting choice tribute Walter feel privileged serve guest editor special issue Acta Informatica honour colleague friend Walter Vogler occasion 60th birthday Walter � high scientific standard many publication Acta Informatica make journal fitting choice tribute Walter
process algebra community sometimes suggested level abstraction distributed system modelled standard process-algebraic specification formalism like CCS sentiment strengthened result testifying CCS like many similar formalism Turing powerful provides mechanism interaction paper counter sentiment presenting simple fair scheduler�one suitable variation occurs many distributed systems�of implementation expressed CCS unless CCS enriched fairness assumption Since Dekker � Peterson � mutual exclusion protocol implement fair scheduler follows protocol rendered correctly CCS without imposing fairness assumption Peterson expressed algorithm correctly pseudocode without resorting fairness assumption furthermore follows CCS lack expressive power accurately capture pseudocode process algebra community sometimes suggested level abstraction distributed system modelled standard process-algebraic specification formalism like CCS sentiment strengthened result testifying CCS like many similar formalism Turing powerful provides mechanism interaction paper counter sentiment presenting simple fair scheduler�one suitable variation occurs many distributed systems�of implementation expressed CCS unless CCS enriched fairness assumption Since Dekker � Peterson � mutual exclusion protocol implement fair scheduler follows protocol rendered correctly CCS without imposing fairness assumption Peterson expressed algorithm correctly pseudocode without resorting fairness assumption furthermore follows CCS lack expressive power accurately capture pseudocode
An LTS operator constructed set LTS operator equivalence LTS expression contains operator set whose result equivalent result operator publication idea made precise context LTS alphabet operator may depend alphabet Then extent LTS operator constructible studied Most established LTS operator property trace result arises execution one trace argument LTSs similarly infinite trace All LTS operator property satisfy rather weak regularity property constructed parallel composition hiding equivalence compare alphabet trace infinite trace LTSs Furthermore collection miscellaneous constructibility unconstructibility result presented An LTS operator constructed set LTS operator equivalence LTS expression contains operator set whose result equivalent result operator publication idea made precise context LTS alphabet operator may depend alphabet Then extent LTS operator constructible studied Most established LTS operator property trace result arises execution one trace argument LTSs similarly infinite trace All LTS operator property satisfy rather weak regularity property constructed parallel composition hiding equivalence compare alphabet trace infinite trace LTSs Furthermore collection miscellaneous constructibility unconstructibility result presented
Modal transition system MTS well-studied specification formalism reactive system supporting step-wise refinement methodology Despite many advantage formalism well currently known extension incapable expressing practically needed aspect refinement process like exclusive conditional persistent choice introduce new model called parametric modal transition system PMTS together general modal refinement notion overcomes many limitation investigate computational complexity modal thorough refinement checking PMTS subclass provide direct encoding modal refinement problem quantified Boolean formula allowing u employ state-of-the-art QBF solver modal refinement checking experiment report show feasibility refinement checking influenced degree nondeterminism rather syntactic restriction type formula allowed description PMTS Modal transition system MTS well-studied specification formalism reactive system supporting step-wise refinement methodology Despite many advantage formalism well currently known extension incapable expressing practically needed aspect refinement process like exclusive conditional persistent choice introduce new model called parametric modal transition system PMTS together general modal refinement notion overcomes many limitation investigate computational complexity modal thorough refinement checking PMTS subclass provide direct encoding modal refinement problem quantified Boolean formula allowing u employ state-of-the-art QBF solver modal refinement checking experiment report show feasibility refinement checking influenced degree nondeterminism rather syntactic restriction type formula allowed description PMTS
Whereas Petri net traditional liveness property guarantee transition Petri net always occur observable liveness requires reachable marking observable transition forced fire choosing appropriate controllable transition hence defined Petri net distinguished observable controllable transition introduce observable liveness show new notion generalizes traditional liveness various way particular liveness 1-bounded Petri net implies observable liveness provided conflict appear controllable transition assumption refers application uncontrollable part model deterministic machine several deterministic machine whereas user machine modeled controllable part behave arbitrarily Whereas Petri net traditional liveness property guarantee transition Petri net always occur observable liveness requires reachable marking observable transition forced fire choosing appropriate controllable transition hence defined Petri net distinguished observable controllable transition introduce observable liveness show new notion generalizes traditional liveness various way particular liveness 1-bounded Petri net implies observable liveness provided conflict appear controllable transition assumption refers application uncontrollable part model deterministic machine several deterministic machine whereas user machine modeled controllable part behave arbitrarily
show interface theory supporting pairwise component analysis extended generic way multi-component environment lead abstract framework assembly theory capture notion assembly refinement communication-safety assembly interacting component An assembly theory support also encapsulation assembly interface hence hierarchical construction propose general rule satisfied concrete assembly theory like compositional construction refinement communication-safe assembly discus general procedure construct assembly theory top given interface theory law assembly theory automatically guaranteed property underlying interface theory proof concept consider two instance approach first one start optimistic interface theory interface automaton proposed de Alfaro Henzinger second one pessimistic interface theory modal I/O-interfaces latter case propose new notion modal assembly refinement required property particular preserve modal communication-safety assembly small case-study illustrates concept methodologically applied show interface theory supporting pairwise component analysis extended generic way multi-component environment lead abstract framework assembly theory capture notion assembly refinement communication-safety assembly interacting component An assembly theory support also encapsulation assembly interface hence hierarchical construction propose general rule satisfied concrete assembly theory like compositional construction refinement communication-safe assembly discus general procedure construct assembly theory top given interface theory law assembly theory automatically guaranteed property underlying interface theory proof concept consider two instance approach first one start optimistic interface theory interface automaton proposed de Alfaro Henzinger second one pessimistic interface theory modal I/O-interfaces latter case propose new notion modal assembly refinement required property particular preserve modal communication-safety assembly small case-study illustrates concept methodologically applied
use well established setting modal semirings derive modal algebra Petri net It based relation-algebraic calculus separation logic enables calculation property pointfree fashion abstract level Basically start earlier logical approach Petri net particular us modal box diamond operator stating property state space net provide relational translation logical formula allow characterisation general behaviour transition algebraic fashion From relational structure algebra frequently used property Petri net derived particular give connection typical used assertion class separation logic Moreover demonstrate applicability algebraic approach calculation concerning standard example mutex net use well established setting modal semirings derive modal algebra Petri net It based relation-algebraic calculus separation logic enables calculation property pointfree fashion abstract level Basically start earlier logical approach Petri net particular us modal box diamond operator stating property state space net provide relational translation logical formula allow characterisation general behaviour transition algebraic fashion From relational structure algebra frequently used property Petri net derived particular give connection typical used assertion class separation logic Moreover demonstrate applicability algebraic approach calculation concerning standard example mutex net
T-systems generalisation marked graph Petri net paper describes synthesis algorithm allow bounded unbounded T-systems derived finite infinite labelled transition system satisfying set necessary property These property thus interpreted axiom characterising T-system state space T-systems generalisation marked graph Petri net paper describes synthesis algorithm allow bounded unbounded T-systems derived finite infinite labelled transition system satisfying set necessary property These property thus interpreted axiom characterising T-system state space
June 2000 meeting took place grand old building Technical University Munich Manfred Broy Managing Editor Acta Informatica since 1982 Hans W�ssner Springer-Verlag agreed August 2000 onward I would take task Managing Editor Acta Informatica Manfred Broy June 2000 meeting took place grand old building Technical University Munich Manfred Broy Managing Editor Acta Informatica since 1982 Hans W�ssner Springer-Verlag agreed August 2000 onward I would take task Managing Editor Acta Informatica Manfred Broy
March 1988 organised workshop � Combining Compositionality Concurrency � K�nigswinter near Bonn Germany motivated following dichotomy One one hand theory concurrency initiated Carl Adam Petri notion like causality conflict concurrency One hand theory communicating process developed Robin Milner Tony Hoare emphasis put composing process algebraic operator like sequential nondeterministic parallel composition March 1988 organised workshop � Combining Compositionality Concurrency � K�nigswinter near Bonn Germany motivated following dichotomy One one hand theory concurrency initiated Carl Adam Petri notion like causality conflict concurrency One hand theory communicating process developed Robin Milner Tony Hoare emphasis put composing process algebraic operator like sequential nondeterministic parallel composition
formal verification structural object program Petri net given question asked behaviour system synthesis conversely behavioural object transition system given question asked existence structural object realising behaviour system reengineering one wish transform given system another one similar behaviour property enjoyed original system paper address synthesis reengineering problem specific framework finite-state labelled transition system place/transition Petri net behaviour isomorphism Since algorithm solving problem prohibitively time-consuming general interesting know whether improved restricted circumstance whether direct correspondence found class behavioural class structural object paper concerned persistent system occur hardware design various application shall derive exact condition finite persistent transition system isomorphically implementable bounded Petri net exhibiting persistence structural way derive efficient algorithm find net one exists For class marked graph Petri net lead exact characterisation state space formal verification structural object program Petri net given question asked behaviour system synthesis conversely behavioural object transition system given question asked existence structural object realising behaviour system reengineering one wish transform given system another one similar behaviour property enjoyed original system paper address synthesis reengineering problem specific framework finite-state labelled transition system place/transition Petri net behaviour isomorphism Since algorithm solving problem prohibitively time-consuming general interesting know whether improved restricted circumstance whether direct correspondence found class behavioural class structural object paper concerned persistent system occur hardware design various application shall derive exact condition finite persistent transition system isomorphically implementable bounded Petri net exhibiting persistence structural way derive efficient algorithm find net one exists For class marked graph Petri net lead exact characterisation state space
logic PML probabilistic version Hennessy�Milner logic introduced Larsen Skou characterize bisimilarity probabilistic process without internal nondeterminism paper two alternative interpretation PML nondeterministic probabilistic process model considered two new bisimulation-based equivalence full agreement interpretation provided new equivalence include coarsest congruence two bisimilarities nondeterministic probabilistic process proposed Segala Lynch latter equivalence instead known agree two version Hennessy�Milner logic extended additional probabilistic operator interpreted state distribution place individual state new interpretation PML corresponding new bisimilarities thus first one offer uniform framework reasoning process purely nondeterministic reactive probabilistic mix nondeterminism probability alternating/nonalternating way logic PML probabilistic version Hennessy�Milner logic introduced Larsen Skou characterize bisimilarity probabilistic process without internal nondeterminism paper two alternative interpretation PML nondeterministic probabilistic process model considered two new bisimulation-based equivalence full agreement interpretation provided new equivalence include coarsest congruence two bisimilarities nondeterministic probabilistic process proposed Segala Lynch latter equivalence instead known agree two version Hennessy�Milner logic extended additional probabilistic operator interpreted state distribution place individual state new interpretation PML corresponding new bisimilarities thus first one offer uniform framework reasoning process purely nondeterministic reactive probabilistic mix nondeterminism probability alternating/nonalternating way
paper recast classical Darondeau�Degano � causal semantics concurrency coalgebraic setting derive compact model construction inspired one Montanari Pistore yielding causal automaton show instance existing categorical framework modeling semantics nominal calculus whose relevance demonstrated key idea represent event name occurrence new event name generation model causal semantics coalgebra presheaf along line Fiore�Turi approach semantics nominal calculus More specifically take suitable category finite posets representing causal relation event equip endofunctor allocates new event relates cause Presheaves category express relationship process causal relation among process � event use allocation operator define category well-behaved coalgebras model occurrence new event along transition Then turn causal transition relation coalgebra category label exhibit maximal event respect source state � poset show bisimilarity essentially Darondeau�Degano � strong causal bisimilarity coalgebra still infinite-state exploit equivalence coalgebras class presheaves History Dependent automaton derive compact representation state retain poset recent event atomic subprocess isomorphic order-preserving permutation Remarkably reduction state automatically performed along equivalence paper recast classical Darondeau�Degano � causal semantics concurrency coalgebraic setting derive compact model construction inspired one Montanari Pistore yielding causal automaton show instance existing categorical framework modeling semantics nominal calculus whose relevance demonstrated key idea represent event name occurrence new event name generation model causal semantics coalgebra presheaf along line Fiore�Turi approach semantics nominal calculus More specifically take suitable category finite posets representing causal relation event equip endofunctor allocates new event relates cause Presheaves category express relationship process causal relation among process � event use allocation operator define category well-behaved coalgebras model occurrence new event along transition Then turn causal transition relation coalgebra category label exhibit maximal event respect source state � poset show bisimilarity essentially Darondeau�Degano � strong causal bisimilarity coalgebra still infinite-state exploit equivalence coalgebras class presheaves History Dependent automaton derive compact representation state retain poset recent event atomic subprocess isomorphic order-preserving permutation Remarkably reduction state automatically performed along equivalence
Unary deterministic one-way multi-head finite automaton characterize unary regular language Here studied respect existence head state hierarchy It turn fixed number state infinite proper head hierarchy particular head hierarchy stateless deterministic one-way multi-head finite automaton obtained using unary language On hand shown fixed number head m+1\ state powerful m\ state Finally open question whether emptiness undecidable stateless one-way two-head finite automaton addressed partial answer undecidability shown least four state provided Unary deterministic one-way multi-head finite automaton characterize unary regular language Here studied respect existence head state hierarchy It turn fixed number state infinite proper head hierarchy particular head hierarchy stateless deterministic one-way multi-head finite automaton obtained using unary language On hand shown fixed number head m+1\ state powerful m\ state Finally open question whether emptiness undecidable stateless one-way two-head finite automaton addressed partial answer undecidability shown least four state provided
study open system modeled Petri net interface asynchronous i.e buffered communication open system minimal requirement successful communication investigate responsiveness guarantee open system environment always possibility communicate investigate responsiveness without final state also respective bounded variant number pending message never exceeds previously known bound Responsiveness accordance describes one open system safely replaced another open system present trace-based characterization accordance variant none relation turn compositional i.e precongruence characterize coarsest compositional relation i.e coarsest precongruence contained relation using variation testing For two unbounded variant precongruences decidable two bounded variant show decidability study open system modeled Petri net interface asynchronous i.e buffered communication open system minimal requirement successful communication investigate responsiveness guarantee open system environment always possibility communicate investigate responsiveness without final state also respective bounded variant number pending message never exceeds previously known bound Responsiveness accordance describes one open system safely replaced another open system present trace-based characterization accordance variant none relation turn compositional i.e precongruence characterize coarsest compositional relation i.e coarsest precongruence contained relation using variation testing For two unbounded variant precongruences decidable two bounded variant show decidability
LR goto-graph basis construction parser several interesting grammar class LALR GLR Early work shown even grammar extension another goto-graph first necessarily subgraph second Some author presented algorithm grow shrink graph incrementally formal proof existence particular relation given goto-graph grown shrunk counterpart seems still missing literature today paper use recursive projection path limited length prove existence one relation set production subset relation also use relation present two algorithm Grow Shrink transform goto-graph given grammar goto-graph extension restriction grammar implemented algorithm dynamically updatable LALR parser generator called DEXTER Dynamically EXTEnsible Recognizer shipping current implementation Neverlang framework programming language development LR goto-graph basis construction parser several interesting grammar class LALR GLR Early work shown even grammar extension another goto-graph first necessarily subgraph second Some author presented algorithm grow shrink graph incrementally formal proof existence particular relation given goto-graph grown shrunk counterpart seems still missing literature today paper use recursive projection path limited length prove existence one relation set production subset relation also use relation present two algorithm Grow Shrink transform goto-graph given grammar goto-graph extension restriction grammar implemented algorithm dynamically updatable LALR parser generator called DEXTER Dynamically EXTEnsible Recognizer shipping current implementation Neverlang framework programming language development
For graph class \mathcal H \mathcal H -Contraction problem take input graph G\ integer k\ asks whether exists graph H\in \mathcal H G\ modified H\ using k\ edge contraction study parameterized complexity \mathcal H -Contraction three different class \mathcal H class \mathcal H \le graph maximum degree d\ class \mathcal H =d d\ -regular graph class d\ -degenerate graph completely classify parameterized complexity three problem respect parameter k\ d\ d+k\ Moreover show \mathcal H -Contraction admits O k vertex kernel connected graph \mathcal H \in \mathcal H \le \mathcal H =2 problem \mathsf W [ ] -hard \mathcal H class 2\ -degenerate graph hence expected admit kernel particular result imply \mathcal H -Contraction admits linear vertex kernel \mathcal H class cycle For graph class \mathcal H \mathcal H -Contraction problem take input graph G\ integer k\ asks whether exists graph H\in \mathcal H G\ modified H\ using k\ edge contraction study parameterized complexity \mathcal H -Contraction three different class \mathcal H class \mathcal H \le graph maximum degree d\ class \mathcal H =d d\ -regular graph class d\ -degenerate graph completely classify parameterized complexity three problem respect parameter k\ d\ d+k\ Moreover show \mathcal H -Contraction admits O k vertex kernel connected graph \mathcal H \in \mathcal H \le \mathcal H =2 problem \mathsf W [ ] -hard \mathcal H class 2\ -degenerate graph hence expected admit kernel particular result imply \mathcal H -Contraction admits linear vertex kernel \mathcal H class cycle
Golomb ruler special ruler two mark hold distance unique They find application radio frequency selection radio astronomy data encryption communication network bioinformatics An important subproblem constructing � compact � Golomb ruler Golomb Subruler GSR asks whether possible make given ruler Golomb removing k\ mark initiate study GSR parameterized complexity perspective particular consider natural hypergraph characterization ruler investigate construction structure corresponding hypergraphs exploit property derive polynomial-time data reduction rule reduce given instance GSR equivalent one \mathrm O k^3 mark Finally complement recent computational complexity study GSR providing simplified reduction show NP-hardness even integer bounded polynomial input length Golomb ruler special ruler two mark hold distance unique They find application radio frequency selection radio astronomy data encryption communication network bioinformatics An important subproblem constructing � compact � Golomb ruler Golomb Subruler GSR asks whether possible make given ruler Golomb removing k\ mark initiate study GSR parameterized complexity perspective particular consider natural hypergraph characterization ruler investigate construction structure corresponding hypergraphs exploit property derive polynomial-time data reduction rule reduce given instance GSR equivalent one \mathrm O k^3 mark Finally complement recent computational complexity study GSR providing simplified reduction show NP-hardness even integer bounded polynomial input length
Equivalence reasoning distributed system model expressed directly imperative program explicit parallelism communication operation storage variable boolean condition remains virtually unexplored Only reasoning model expressed process algebra amply dealt literature However formalism contemplate either storage variable Boolean condition fundamental item although item become essential situation article develops foundation non existent theory equivalence reasoning aforementioned imperative notation two novel equivalence proof technique communication elimination sequentialization development grounded state system transition interleavings treated Manna Pnueli Equivalence proof safely transform model via application sequence equivalence law aiming obtain equivalent model purely sequential free internal communication operation parallelism simplification initial model After verification original model carried indirectly simplified model thus reducing complexity Some presented novel notion modular procedure decomposition model proof interface behavior statement semantics interface equivalence behavior statement procedure set communication elimination law substitution rule procedure reference body reference equivalent procedure An elimination proof construction algorithm also presented terminates deadlock freedom original model decided main design line computer aided equivalence reasoning tool outlined well foundation widely applicable tool illustration sequentialization proof simplified pipelined processor overviewed It modeled distributed system procedure two level parallelism model obtained end equivalence proof sequential loop Von Neumann processor result establishes original model deadlock-free behaves processor consequence partition processor function among parallel process correct ratio upper bound number state final initial model \frac final initial \frac 2^ 672 Equivalence reasoning distributed system model expressed directly imperative program explicit parallelism communication operation storage variable boolean condition remains virtually unexplored Only reasoning model expressed process algebra amply dealt literature However formalism contemplate either storage variable Boolean condition fundamental item although item become essential situation article develops foundation non existent theory equivalence reasoning aforementioned imperative notation two novel equivalence proof technique communication elimination sequentialization development grounded state system transition interleavings treated Manna Pnueli Equivalence proof safely transform model via application sequence equivalence law aiming obtain equivalent model purely sequential free internal communication operation parallelism simplification initial model After verification original model carried indirectly simplified model thus reducing complexity Some presented novel notion modular procedure decomposition model proof interface behavior statement semantics interface equivalence behavior statement procedure set communication elimination law substitution rule procedure reference body reference equivalent procedure An elimination proof construction algorithm also presented terminates deadlock freedom original model decided main design line computer aided equivalence reasoning tool outlined well foundation widely applicable tool illustration sequentialization proof simplified pipelined processor overviewed It modeled distributed system procedure two level parallelism model obtained end equivalence proof sequential loop Von Neumann processor result establishes original model deadlock-free behaves processor consequence partition processor function among parallel process correct ratio upper bound number state final initial model \frac final initial \frac 2^ 672
If length primitive word p\ equal length another primitive word q\ p^ n q^ primitive word n m\ge 1\ n \ne obtained separately Tetsuo Moriya 2008 Shyr Yu 1994 paper prove length p\ divisible length q\ length p\ le equal m\ time length q\ p^ n q^ primitive word n m\ge 1\ n \ne Then show uv u\ non-primitive word length u\ divisible length v\ one length u\ uv\ odd two nonempty word u\ v\ u\ power v\ If length primitive word p\ equal length another primitive word q\ p^ n q^ primitive word n m\ge 1\ n \ne obtained separately Tetsuo Moriya 2008 Shyr Yu 1994 paper prove length p\ divisible length q\ length p\ le equal m\ time length q\ p^ n q^ primitive word n m\ge 1\ n \ne Then show uv u\ non-primitive word length u\ divisible length v\ one length u\ uv\ odd two nonempty word u\ v\ u\ power v\
paper proposes new theory quantitative specification It generalizes notion step-wise refinement compositional design operation Boolean arbitrary quantitative setting Using great number example shown general approach permit unify many interesting quantitative approach system design paper proposes new theory quantitative specification It generalizes notion step-wise refinement compositional design operation Boolean arbitrary quantitative setting Using great number example shown general approach permit unify many interesting quantitative approach system design
paper discus finite automaton regulated control language state transition rule It prof regulation regular-controlled finite automaton context-free-controlled finite automaton characterize family regular language family context-free language respectively It also establishes condition state-controlled finite automaton turned equivalent transition-controlled finite automaton vice versa paper also demonstrates close relation automaton programmed grammar Indeed prof finite automaton controlled language generated propagating programmed grammar appearance checking computationally complete fact demonstrates computational completeness hold even term automaton reduced number state paper discus finite automaton regulated control language state transition rule It prof regulation regular-controlled finite automaton context-free-controlled finite automaton characterize family regular language family context-free language respectively It also establishes condition state-controlled finite automaton turned equivalent transition-controlled finite automaton vice versa paper also demonstrates close relation automaton programmed grammar Indeed prof finite automaton controlled language generated propagating programmed grammar appearance checking computationally complete fact demonstrates computational completeness hold even term automaton reduced number state
consider symbolic tree automaton sta symbolic regular tree grammar corresponding class tree language s-recognizable tree language s-regular tree language prove following three class equal class s-recognizable tree language class s-regular tree language class image classical recognizable tree language tree relabelings Moreover sta recently introduced variable tree automaton incomparable respect recognition power Also consider symbolic tree transducer stt prove following theorem syntactic composition two stt computes composition tree transformation computed stt provided first one deterministic second one linear first one total second one nondeleting Backward application stt s-recognizable tree language yield s-recognizable tree language There linear stt range s-recognizable tree language Forward application simple linear stt preserve s-recognizability restricted version type checking problem simple linear stt inverse type checking problem arbitrary stt decidable Since deal tree infinite alphabet require appropriate condition sta stt proof constructive consider symbolic tree automaton sta symbolic regular tree grammar corresponding class tree language s-recognizable tree language s-regular tree language prove following three class equal class s-recognizable tree language class s-regular tree language class image classical recognizable tree language tree relabelings Moreover sta recently introduced variable tree automaton incomparable respect recognition power Also consider symbolic tree transducer stt prove following theorem syntactic composition two stt computes composition tree transformation computed stt provided first one deterministic second one linear first one total second one nondeleting Backward application stt s-recognizable tree language yield s-recognizable tree language There linear stt range s-recognizable tree language Forward application simple linear stt preserve s-recognizability restricted version type checking problem simple linear stt inverse type checking problem arbitrary stt decidable Since deal tree infinite alphabet require appropriate condition sta stt proof constructive
It spectacular observe retrospect deep computer integrated life quite short period incurs great responsibility failure result damage disruption well Formal method collection technique testing verifying correctness software based logic automaton theory essence formal method used verify compatibility system formal specification Modern formal method provide counterexample compatibility hold ability provide counterexample perhaps important feature method It used inform designer programmer problem locate However counterexample may give ample information cause error may happen far affect observed Moreover even clear correct specific problem error may detected even introduced previous one corrected It spectacular observe retrospect deep computer integrated life quite short period incurs great responsibility failure result damage disruption well Formal method collection technique testing verifying correctness software based logic automaton theory essence formal method used verify compatibility system formal specification Modern formal method provide counterexample compatibility hold ability provide counterexample perhaps important feature method It used inform designer programmer problem locate However counterexample may give ample information cause error may happen far affect observed Moreover even clear correct specific problem error may detected even introduced previous one corrected
paper offer efficient controller synthesis algorithm assume-guarantee specification form \varphi _1 \wedge \varphi _2 \wedge \cdots \wedge \varphi _n \rightarrow \psi _1 \wedge \psi _2 \wedge \cdots \wedge \psi _m\ Here \varphi _i \psi _j\ safety-MTL\ \infty property sub-formulas \varphi _i\ supposed specify assumption environment sub-formulas \psi _j\ specifying requirement guaranteed controller synthesis method exploit engine Uppaal-Tiga novel translation safety- co-safety-MTL\ \infty property under-approximating deterministic timed automaton approach avoids determinization B�chi automaton main obstacle practical applicability controller synthesis linear-time specification experiment demonstrate chosen specification formalism expressive enough specify complex behavior proposed approach sound complete However successfully produced solution experiment Additionally compared tool Acacia+ Unbeast state-of-the-art LTL synthesis tool tool demonstrated better timing result applied tool analogous specification paper offer efficient controller synthesis algorithm assume-guarantee specification form \varphi _1 \wedge \varphi _2 \wedge \cdots \wedge \varphi _n \rightarrow \psi _1 \wedge \psi _2 \wedge \cdots \wedge \psi _m\ Here \varphi _i \psi _j\ safety-MTL\ \infty property sub-formulas \varphi _i\ supposed specify assumption environment sub-formulas \psi _j\ specifying requirement guaranteed controller synthesis method exploit engine Uppaal-Tiga novel translation safety- co-safety-MTL\ \infty property under-approximating deterministic timed automaton approach avoids determinization B�chi automaton main obstacle practical applicability controller synthesis linear-time specification experiment demonstrate chosen specification formalism expressive enough specify complex behavior proposed approach sound complete However successfully produced solution experiment Additionally compared tool Acacia+ Unbeast state-of-the-art LTL synthesis tool tool demonstrated better timing result applied tool analogous specification
consider distributed realizability problem system regular deterministic contextfree local specification characterize exactly architecture realizability problem decidable extends known result local specification two direction First architecture cycle allowed instead acyclic one second deterministic contextfree specification considered consider distributed realizability problem system regular deterministic contextfree local specification characterize exactly architecture realizability problem decidable extends known result local specification two direction First architecture cycle allowed instead acyclic one second deterministic contextfree specification considered
Systems correct also robust sense behave reasonably unexpected situation article address synthesis robust reactive system temporal specification Existing method allow arbitrary behavior assumption specification violated overcome define two robustness notion combine show enforce synthesis first notion applies safety property If safety assumption violated temporarily require system recovers normal operation error possible second notion requires liveness assumption violated many guarantee possible fulfilled nevertheless present synthesis procedure achieving important class GR specification establish complexity bound also present implementation special case robustness show experimental result Systems correct also robust sense behave reasonably unexpected situation article address synthesis robust reactive system temporal specification Existing method allow arbitrary behavior assumption specification violated overcome define two robustness notion combine show enforce synthesis first notion applies safety property If safety assumption violated temporarily require system recovers normal operation error possible second notion requires liveness assumption violated many guarantee possible fulfilled nevertheless present synthesis procedure achieving important class GR specification establish complexity bound also present implementation special case robustness show experimental result
Multi-dimensional mean-payoff energy game provide mathematical foundation quantitative study reactive system play central role emerging quantitative theory verification synthesis work study strategy synthesis problem game multi-dimensional objective along parity condition canonical way express \omega -regular condition While general winning strategy game may require infinite memory synthesis relevant problem construction finite-memory winning strategy one exists main contribution follows First show tight exponential bound matching upper lower bound memory required finite-memory winning strategy multi-dimensional mean-payoff energy game along parity objective significantly improves triple exponential upper bound multi energy game without parity could derived result literature game vector addition system state Second present optimal symbolic incremental algorithm compute finite-memory winning strategy one exists game Finally give complete characterization finite memory strategy traded randomness particular show one-dimension mean-payoff parity game randomized memoryless strategy powerful pure finite-memory counterpart Multi-dimensional mean-payoff energy game provide mathematical foundation quantitative study reactive system play central role emerging quantitative theory verification synthesis work study strategy synthesis problem game multi-dimensional objective along parity condition canonical way express \omega -regular condition While general winning strategy game may require infinite memory synthesis relevant problem construction finite-memory winning strategy one exists main contribution follows First show tight exponential bound matching upper lower bound memory required finite-memory winning strategy multi-dimensional mean-payoff energy game along parity objective significantly improves triple exponential upper bound multi energy game without parity could derived result literature game vector addition system state Second present optimal symbolic incremental algorithm compute finite-memory winning strategy one exists game Finally give complete characterization finite memory strategy traded randomness particular show one-dimension mean-payoff parity game randomized memoryless strategy powerful pure finite-memory counterpart
introduce linear temporal logic first-order logic weighted setup max-plus semiring discounting parameter [ Furthermore define \omega \hbox - d\ -star-free series counter-free weighted B�chi automaton show class series definable fragment weighted linear temporal logic first-order logic class \omega \hbox - d\ -star-free series subclass \omega \hbox - d\ -counter-free series coincide extends fundamental result first-order logic theory series max-plus semiring discounting introduce linear temporal logic first-order logic weighted setup max-plus semiring discounting parameter [ Furthermore define \omega \hbox - d\ -star-free series counter-free weighted B�chi automaton show class series definable fragment weighted linear temporal logic first-order logic class \omega \hbox - d\ -star-free series subclass \omega \hbox - d\ -counter-free series coincide extends fundamental result first-order logic theory series max-plus semiring discounting
number algorithm computing simulation preorder equivalence Kripke structure available Let \varSigma denote state space \rightarrow transition relation P_ \mathrm sim partition \varSigma induced simulation equivalence While algorithm designed reach best space bound whose dominating additive term |P_ \mathrm sim |^2\ algorithm devised attain best time complexity O |P_ \mathrm sim \rightarrow present novel simulation algorithm space time efficient run O |P_ \mathrm sim |^2 \log |P_ \mathrm sim |\varSigma |\log |\varSigma space O |P_ \mathrm sim \rightarrow |\log |\varSigma time simulation algorithm thus reach best space bound closely approaching best time complexity number algorithm computing simulation preorder equivalence Kripke structure available Let \varSigma denote state space \rightarrow transition relation P_ \mathrm sim partition \varSigma induced simulation equivalence While algorithm designed reach best space bound whose dominating additive term |P_ \mathrm sim |^2\ algorithm devised attain best time complexity O |P_ \mathrm sim \rightarrow present novel simulation algorithm space time efficient run O |P_ \mathrm sim |^2 \log |P_ \mathrm sim |\varSigma |\log |\varSigma space O |P_ \mathrm sim \rightarrow |\log |\varSigma time simulation algorithm thus reach best space bound closely approaching best time complexity
paper investigates performance multicast cooperative ARQ MCARQ wireless network reducing system � waiting time sum energy delay energy analytical model proposed equivalent service time ideal Nyquist pulse packet transmission process modulated three-state Markov chain steady-state distribution MCARQ obtained solving Markov chain Further queue waiting time energy efficiency multicast ARQ MARQ MCARQ obtained respectively Theoretical analysis simulation result demonstrate MCARQ protocol better performance MARQ delay energy efficiency presented model potentially application practical system Multi-user MIMO communication paper investigates performance multicast cooperative ARQ MCARQ wireless network reducing system � waiting time sum energy delay energy analytical model proposed equivalent service time ideal Nyquist pulse packet transmission process modulated three-state Markov chain steady-state distribution MCARQ obtained solving Markov chain Further queue waiting time energy efficiency multicast ARQ MARQ MCARQ obtained respectively Theoretical analysis simulation result demonstrate MCARQ protocol better performance MARQ delay energy efficiency presented model potentially application practical system Multi-user MIMO communication
define language-independent model nondeterministic quantum program quantum program consists finite set quantum process These process represented quantum Markov chain common state space formalize quantum mechanical behavior machine An execution nondeterministic quantum program modeled sequence action individual process step execution process chosen nondeterministically perform next action execution model formalize user � behavior calling process classical world Applying model quantum walk instance physically realizable system describe execution step step characterization reachable space characterization diverging state nondeterministic quantum program presented establish zero-one law termination probability state reachable space combination result lead necessary sufficient condition termination nondeterministic quantum program Based condition algorithm found checking termination nondeterministic quantum program within fixed finite-dimensional state space define language-independent model nondeterministic quantum program quantum program consists finite set quantum process These process represented quantum Markov chain common state space formalize quantum mechanical behavior machine An execution nondeterministic quantum program modeled sequence action individual process step execution process chosen nondeterministically perform next action execution model formalize user � behavior calling process classical world Applying model quantum walk instance physically realizable system describe execution step step characterization reachable space characterization diverging state nondeterministic quantum program presented establish zero-one law termination probability state reachable space combination result lead necessary sufficient condition termination nondeterministic quantum program Based condition algorithm found checking termination nondeterministic quantum program within fixed finite-dimensional state space
Regular expression RE algebraic formalism expressing regular language widely used string search specification language verification paper introduce investigate visibly rational expression VRE extension RE class visibly pushdown language VPL show VRE capture precisely class VPL Moreover identify equally expressive fragment VRE admits quadratic time compositional translation automaton acceptor VPL also prove fragment universality inclusion language equivalence EXPTIME-complete Finally provide extension VRE VPL infinite word Regular expression RE algebraic formalism expressing regular language widely used string search specification language verification paper introduce investigate visibly rational expression VRE extension RE class visibly pushdown language VPL show VRE capture precisely class VPL Moreover identify equally expressive fragment VRE admits quadratic time compositional translation automaton acceptor VPL also prove fragment universality inclusion language equivalence EXPTIME-complete Finally provide extension VRE VPL infinite word
Transient secure association widely accepted possible alternative traditional authentication context Ubiquitous Computing Two component distributed system transient secure association may share master-slave relationship creates hierarchical dynamic structure component paper develop several formal model distributed system transient secure association incremental expressive power based Petri net first model call transient secure association TSA system considers finitely many component Then consider small extension TSA system slave initialized whenever master-slave relation broken Last define unbounded TSA uTSA system number component bounded For defined formalism establish link known class Petri net thus inheriting corresponding un decidability result Transient secure association widely accepted possible alternative traditional authentication context Ubiquitous Computing Two component distributed system transient secure association may share master-slave relationship creates hierarchical dynamic structure component paper develop several formal model distributed system transient secure association incremental expressive power based Petri net first model call transient secure association TSA system considers finitely many component Then consider small extension TSA system slave initialized whenever master-slave relation broken Last define unbounded TSA uTSA system number component bounded For defined formalism establish link known class Petri net thus inheriting corresponding un decidability result
study extend modal type system based intuitionistic modal logic S4 S5 subtyping system based intersection type presence four type constructor ! ! \rightarrow ! ! ! \wedge ! \square \Diamond traditional approach using binary subtyping relation work well lack orthogonality subtyping rule presence transitivity rule adopt idea judgmental formulation modal logic Pfenning Davies Math Struct Comput Sci 11 :511�540 2001 use subtyping judgment whose definition express notion internalized type constructor directly level judgment resultant judgmental subtyping system admit cut rule similarly sequent calculus intuitionistic logic play key role designing verifying relational subtyping system based binary subtyping relation use proof assistant Coq prove admissibility cut rule equivalence two kind subtyping system lesson study using subtyping judgment instead binary subtyping relation overcome limitation usually associated syntactic approach formulating subtyping system study extend modal type system based intuitionistic modal logic S4 S5 subtyping system based intersection type presence four type constructor ! ! \rightarrow ! ! ! \wedge ! \square \Diamond traditional approach using binary subtyping relation work well lack orthogonality subtyping rule presence transitivity rule adopt idea judgmental formulation modal logic Pfenning Davies Math Struct Comput Sci 11 :511�540 2001 use subtyping judgment whose definition express notion internalized type constructor directly level judgment resultant judgmental subtyping system admit cut rule similarly sequent calculus intuitionistic logic play key role designing verifying relational subtyping system based binary subtyping relation use proof assistant Coq prove admissibility cut rule equivalence two kind subtyping system lesson study using subtyping judgment instead binary subtyping relation overcome limitation usually associated syntactic approach formulating subtyping system
give partial result factorization conjecture code proposed Sch�tzenberger consider family finite maximal code C\ alphabet = b\ prove factorization conjecture hold code family contains p -codes p -code C\ finite maximal code A\ word C\ four occurrence b\ a^p \in C\ prime number p\ also discus structure code obtained result show relation factorization finite maximal code factorization finite cyclic group give partial result factorization conjecture code proposed Sch�tzenberger consider family finite maximal code C\ alphabet = b\ prove factorization conjecture hold code family contains p -codes p -code C\ finite maximal code A\ word C\ four occurrence b\ a^p \in C\ prime number p\ also discus structure code obtained result show relation factorization finite maximal code factorization finite cyclic group
give simpler proof undecidability circular Post Correspondence Problem originally proved undecidable Ruohonen Acta Informatica 19:357�367 1983 key feature proof undecidability word problem special semi-Thue system derivation deterministic reversible word containing single occurrence letter given set give simpler proof undecidability circular Post Correspondence Problem originally proved undecidable Ruohonen Acta Informatica 19:357�367 1983 key feature proof undecidability word problem special semi-Thue system derivation deterministic reversible word containing single occurrence letter given set
Resource allocation problem process may enter critical section CS code resource requirement conflict process critical section For execution CS requirement given anew resource requirement level distinguished read access write access allow unboundedly many process communicate reliable asynchronous message finite memory simple starvation-free solution presented Processes wait one another conflicting resource requirement correctness solution argued invariant temporal logic It verified proof assistant PVS Resource allocation problem process may enter critical section CS code resource requirement conflict process critical section For execution CS requirement given anew resource requirement level distinguished read access write access allow unboundedly many process communicate reliable asynchronous message finite memory simple starvation-free solution presented Processes wait one another conflicting resource requirement correctness solution argued invariant temporal logic It verified proof assistant PVS
Multi-coloring path model frequency assignment linear cellular network Two model studied previous paper call may either finite infinite duration For hexagonal network variation model limited frequency reassignment allowed also studied add concept frequency reassignment model linear cellular network close problem giving matching upper lower bound case prove randomized algorithm better competitive ratio best deterministic algorithm addition give exact characterization natural greedy algorithm problem All result regard competitive analysis Taking step towards fine-grained analysis consider case finite call frequency reassignment prove even though randomization bring competitive ratio one seems greedy algorithm expected optimal uniform random request sequence prove small path indicate experimentally larger graph Multi-coloring path model frequency assignment linear cellular network Two model studied previous paper call may either finite infinite duration For hexagonal network variation model limited frequency reassignment allowed also studied add concept frequency reassignment model linear cellular network close problem giving matching upper lower bound case prove randomized algorithm better competitive ratio best deterministic algorithm addition give exact characterization natural greedy algorithm problem All result regard competitive analysis Taking step towards fine-grained analysis consider case finite call frequency reassignment prove even though randomization bring competitive ratio one seems greedy algorithm expected optimal uniform random request sequence prove small path indicate experimentally larger graph
paper new dependency added hierarchy distribution-sensitive property data structure Most remarkably prove working-set property equivalent unified-bound property fact gone unnoticed since introduction bound Eighties Sleator Tarjan paper new dependency added hierarchy distribution-sensitive property data structure Most remarkably prove working-set property equivalent unified-bound property fact gone unnoticed since introduction bound Eighties Sleator Tarjan
problem decentralized data sharing relevant wide range application still source major theoretical practical challenge spite many year sustained research paper focus challenge efficiency query evaluation information integration system use global-as-view approach objective developing query-processing strategy would widely applicable easy implement real-life application algorithm take account important feature today � data sharing application XML likely interface representation data source potential information overlap across data source need inter-source processing join data across source focus paper performance-related characteristic several alternative approach propose efficient query processing information integration including approach us materialized restructured view use synthetic real-life datasets implementation information integration system shell provide experimental result demonstrate algorithm efficient competitive information integration setting addition experimental result allow u make context-specific recommendation selecting query-processing approach proposed alternative approach could form basis scalable query processing information integration interoperability many practical setting problem decentralized data sharing relevant wide range application still source major theoretical practical challenge spite many year sustained research paper focus challenge efficiency query evaluation information integration system use global-as-view approach objective developing query-processing strategy would widely applicable easy implement real-life application algorithm take account important feature today � data sharing application XML likely interface representation data source potential information overlap across data source need inter-source processing join data across source focus paper performance-related characteristic several alternative approach propose efficient query processing information integration including approach us materialized restructured view use synthetic real-life datasets implementation information integration system shell provide experimental result demonstrate algorithm efficient competitive information integration setting addition experimental result allow u make context-specific recommendation selecting query-processing approach proposed alternative approach could form basis scalable query processing information integration interoperability many practical setting
Recently one-counter trace language context-free trace language characterized restricted type cooperating distributed system CD-systems stateless deterministic restarting automaton window size one so-called stl-det-R -automata work mode � =1 � use external counter pushdown store determine successor component within computation Here study deterministic variant CD-systems comparing resulting language class class language defined CD-systems stl-det-R -automata without external device classical language family among particular class rational one-counter context-free trace language addition present large number non- closure property language class Recently one-counter trace language context-free trace language characterized restricted type cooperating distributed system CD-systems stateless deterministic restarting automaton window size one so-called stl-det-R -automata work mode � =1 � use external counter pushdown store determine successor component within computation Here study deterministic variant CD-systems comparing resulting language class class language defined CD-systems stl-det-R -automata without external device classical language family among particular class rational one-counter context-free trace language addition present large number non- closure property language class
simplification mutual exclusion algorithm Lycklama Hadzilacos ACM Trans Program Lang Syst 13:558�576 1991 presented It us four nonatomic shared bit per thread guarantee mutual exclusion first-come-first-served property algorithm verified assertional method aided proof assistant PVS variation five bit per thread also given variation may give better performance number thread large use proof assistant made easy transfer proof main algorithm variation simplification mutual exclusion algorithm Lycklama Hadzilacos ACM Trans Program Lang Syst 13:558�576 1991 presented It us four nonatomic shared bit per thread guarantee mutual exclusion first-come-first-served property algorithm verified assertional method aided proof assistant PVS variation five bit per thread also given variation may give better performance number thread large use proof assistant made easy transfer proof main algorithm variation
paper study construction enumeration binary word 1\ ^*\ � � avoiding set cross-bifix-free pattern give particular succession rule called jumping marked succession rule describes growth word according number one Moreover problem associating word path generating tree obtained succession rule solved introducing algorithm construct binary word � � kill containing forbidden pattern Finally give generating function word according number one paper study construction enumeration binary word 1\ ^*\ � � avoiding set cross-bifix-free pattern give particular succession rule called jumping marked succession rule describes growth word according number one Moreover problem associating word path generating tree obtained succession rule solved introducing algorithm construct binary word � � kill containing forbidden pattern Finally give generating function word according number one
paper introduce variant alternating pushdown automaton synchronized alternating pushdown automaton accept class language generated conjunctive grammar paper introduce variant alternating pushdown automaton synchronized alternating pushdown automaton accept class language generated conjunctive grammar
Infinitary Term Rewriting allows express infinite term transfinite reduction converge term Underpinning machinery infinitary rewriting closure operator relation facilitate formation transfinite reduction transfinite equivalence proof literature infinitary rewriting largely neglected single closure operator leaving implicit definition transfinite rewrite reduction equivalence relation paper unpicks definition extracting underlying closure principle used well constructing alternative operator lead alternative notion reduction equivalence consequence unpicking insight abstraction level operator defined Some material paper already appeared Kahrs 2010 paper also generalises notion equational model infinitary rewriting lead semantics-based notion equivalence tie equivalence constructed closure operator Infinitary Term Rewriting allows express infinite term transfinite reduction converge term Underpinning machinery infinitary rewriting closure operator relation facilitate formation transfinite reduction transfinite equivalence proof literature infinitary rewriting largely neglected single closure operator leaving implicit definition transfinite rewrite reduction equivalence relation paper unpicks definition extracting underlying closure principle used well constructing alternative operator lead alternative notion reduction equivalence consequence unpicking insight abstraction level operator defined Some material paper already appeared Kahrs 2010 paper also generalises notion equational model infinitary rewriting lead semantics-based notion equivalence tie equivalence constructed closure operator
Delta-oriented programming compositional approach flexibly implementing software product line product line represented code base product line declaration code base consists set delta module specifying modification object-oriented program particular product delta-oriented product line generated applying modification contained suitable delta module empty program product-line declaration provides connection delta module product feature separation increase reusability delta module paper provide foundation compositional type checking delta-oriented product line Java program presenting minimal core calculus delta-oriented programming calculus equipped constraint-based type system allows analyzing delta module isolation result analysis reused By relying analysis result delta module product line declaration possible establish whether product product line well typed according fragment Java type system modeled calculus Delta-oriented programming compositional approach flexibly implementing software product line product line represented code base product line declaration code base consists set delta module specifying modification object-oriented program particular product delta-oriented product line generated applying modification contained suitable delta module empty program product-line declaration provides connection delta module product feature separation increase reusability delta module paper provide foundation compositional type checking delta-oriented product line Java program presenting minimal core calculus delta-oriented programming calculus equipped constraint-based type system allows analyzing delta module isolation result analysis reused By relying analysis result delta module product line declaration possible establish whether product product line well typed according fragment Java type system modeled calculus
paper propose hierarchy family language generated network evolutionary processor filter belong several special class regular set More precisely show use filter class ordered non-counting power-separating circular suffix-closed regular union-free definite combinational language powerful use arbitrary regular language yield network generate recursively enumerable language On hand use filter finite language allows generation regular language every regular language generated If use filter monoids nilpotent language commutative regular language obtain one family language contains non-context-free language regular language These result seem interest provide upper lower bound family language one use filter network evolutionary processor order obtain complete computational model paper propose hierarchy family language generated network evolutionary processor filter belong several special class regular set More precisely show use filter class ordered non-counting power-separating circular suffix-closed regular union-free definite combinational language powerful use arbitrary regular language yield network generate recursively enumerable language On hand use filter finite language allows generation regular language every regular language generated If use filter monoids nilpotent language commutative regular language obtain one family language contains non-context-free language regular language These result seem interest provide upper lower bound family language one use filter network evolutionary processor order obtain complete computational model
paper propose generalization accepting splicing system introduced Mitrana et al Theor Comput Sci 411:2414�2422 2010 More precisely input word accepted soon permitting word obtained provided forbidding word obtained far otherwise rejected Note new variant accepting splicing system input word rejected either permitting word ever generated like Mitrana et al Theor Comput Sci 411:2414�2422 2010 forbidding word generated permitting word generated investigate computational power new variant accepting splicing system interrelationship among show new condition strictly increase computational power accepting splicing system Although regular language accepted splicing system considered new variant accept non-regular even non-context-free language situation common case extended finite splicing system without additional restriction also show smallest class language four class defined accepting splicing system strictly included class context-free language Solutions decidability problem immediately derived proof result paper propose generalization accepting splicing system introduced Mitrana et al Theor Comput Sci 411:2414�2422 2010 More precisely input word accepted soon permitting word obtained provided forbidding word obtained far otherwise rejected Note new variant accepting splicing system input word rejected either permitting word ever generated like Mitrana et al Theor Comput Sci 411:2414�2422 2010 forbidding word generated permitting word generated investigate computational power new variant accepting splicing system interrelationship among show new condition strictly increase computational power accepting splicing system Although regular language accepted splicing system considered new variant accept non-regular even non-context-free language situation common case extended finite splicing system without additional restriction also show smallest class language four class defined accepting splicing system strictly included class context-free language Solutions decidability problem immediately derived proof result
Boolean net family Petri net model simple marking set place investigate several class boolean net distinguished different kind individual connection place transition well different way connection combined order specify effect executing step transition latter aspect captured connection monoids key advantage using connection monoids describing step semantics class Petri net term connection monoid one apply result developed within general theory Petri net synthesis paper provide extensive classification boolean net described connection monoids classification based realisation different way interpreting combination connection made explicit using higher level monoid Moreover demonstrate connection monoids capture behavioural property boolean net structural conflict transition Boolean net family Petri net model simple marking set place investigate several class boolean net distinguished different kind individual connection place transition well different way connection combined order specify effect executing step transition latter aspect captured connection monoids key advantage using connection monoids describing step semantics class Petri net term connection monoid one apply result developed within general theory Petri net synthesis paper provide extensive classification boolean net described connection monoids classification based realisation different way interpreting combination connection made explicit using higher level monoid Moreover demonstrate connection monoids capture behavioural property boolean net structural conflict transition
It known set primitive word set d\ -primitive word disjunctive language paper prove set p\ -primitive word disjunctive also prove set primitive p\ -primitive word set balanced p\ -primitive word set d\ -primitive p\ -primitive word disjunctive language It known set primitive word set d\ -primitive word disjunctive language paper prove set p\ -primitive word disjunctive also prove set primitive p\ -primitive word set balanced p\ -primitive word set d\ -primitive p\ -primitive word disjunctive language
study random access machine RAMs complexity associated algorithm availability indirect addressing often creates analysis obstacle show RAMs equipped sufficiently rich set basic operation indirect addressing increase computational power simulated either linear time on-line real time These result pertain uniform cost model particularly assume unit cost variable shift study random access machine RAMs complexity associated algorithm availability indirect addressing often creates analysis obstacle show RAMs equipped sufficiently rich set basic operation indirect addressing increase computational power simulated either linear time on-line real time These result pertain uniform cost model particularly assume unit cost variable shift
paper distinguishing relating two important kind calculus expressiveness settling critical long unanswered question delimitation higher-order first-order process calculus basic pivotal topic study process theory Particularly expressiveness study mutual encodability help decide whether process-passing name-passing fundamental way ought used theory practice paper contribute demarcation three major result Firstly \pi first-order pi-calculus faithfully express \varPi basic higher-order pi-calculus calculus \varPi elementary operator input output composition restriction actually corollary general result \pi encode \varPi ^r\ \varPi enriched relabelling operator Secondly \varPi interpret \pi reasonably significance since separate \varPi \pi drawing well-defined boundary Thirdly encoding \pi \varPi ^r\ revisited discussed implies make \varPi useful also stress importance name-passing \pi paper distinguishing relating two important kind calculus expressiveness settling critical long unanswered question delimitation higher-order first-order process calculus basic pivotal topic study process theory Particularly expressiveness study mutual encodability help decide whether process-passing name-passing fundamental way ought used theory practice paper contribute demarcation three major result Firstly \pi first-order pi-calculus faithfully express \varPi basic higher-order pi-calculus calculus \varPi elementary operator input output composition restriction actually corollary general result \pi encode \varPi ^r\ \varPi enriched relabelling operator Secondly \varPi interpret \pi reasonably significance since separate \varPi \pi drawing well-defined boundary Thirdly encoding \pi \varPi ^r\ revisited discussed implies make \varPi useful also stress importance name-passing \pi
paper study scheduling game uniform machine social cost maximizing minimum machine load For game two machine present Strong Price Stability Strong Price Anarchy function ratio speed two machine These bound tight value thus problem measuring inefficiency equilibrium two uniform machine completely solved also give tight Price Anarchy special case three machine From result achieve new interesting insight scheduling game paper study scheduling game uniform machine social cost maximizing minimum machine load For game two machine present Strong Price Stability Strong Price Anarchy function ratio speed two machine These bound tight value thus problem measuring inefficiency equilibrium two uniform machine completely solved also give tight Price Anarchy special case three machine From result achieve new interesting insight scheduling game
aim paper extend family Glushkov automaton achieved designing new operator so-called multi-tilde-bar operator allow u compute Glushkov function associated extended expression Conversely extended Glushkov automaton n+1\ state converted extended expression n\ occurrence symbol It lead characterization term graph family extended Glushkov automaton Moreover extended expression shown superpolynomially succinct standard expression aim paper extend family Glushkov automaton achieved designing new operator so-called multi-tilde-bar operator allow u compute Glushkov function associated extended expression Conversely extended Glushkov automaton n+1\ state converted extended expression n\ occurrence symbol It lead characterization term graph family extended Glushkov automaton Moreover extended expression shown superpolynomially succinct standard expression
study computing power class numerical P system introduced framework autonomous robot control namely enzymatic numerical P system Three way using evolution program investigated sequential all-parallel one-parallel variable used program one respectively moreover deterministic non-deterministic system considered Turing universality obtained class numerical P system proved polynomial smallest possible degree one also introducing new proof technique area namely starting universality proof characterization computable set number mean register machine power many class remains investigated study computing power class numerical P system introduced framework autonomous robot control namely enzymatic numerical P system Three way using evolution program investigated sequential all-parallel one-parallel variable used program one respectively moreover deterministic non-deterministic system considered Turing universality obtained class numerical P system proved polynomial smallest possible degree one also introducing new proof technique area namely starting universality proof characterization computable set number mean register machine power many class remains investigated
Surjective Homomorphism problem test whether given graph G called guest graph allows vertex-surjective homomorphism given graph H called host graph bijective injective homomorphism problem formulated term spanning subgraphs subgraphs computational complexity extensively studied What surjective variant ? Because problem NP-complete general restrict guest host graph belong graph class \mathcal G \mathcal H respectively determine extent certain choice \mathcal G \mathcal H influence computational complexity observe problem polynomial-time solvable \mathcal H class path whereas NP-complete \mathcal G class path Moreover show problem even NP-complete many elementary graph class namely linear forest union complete graph cographs proper interval graph split graph tree pathwidth contrast prove problem fixed-parameter tractable k \mathcal G class tree \mathcal H class tree k leaf \mathcal G \mathcal H equal class graph vertex cover number k Surjective Homomorphism problem test whether given graph G called guest graph allows vertex-surjective homomorphism given graph H called host graph bijective injective homomorphism problem formulated term spanning subgraphs subgraphs computational complexity extensively studied What surjective variant ? Because problem NP-complete general restrict guest host graph belong graph class \mathcal G \mathcal H respectively determine extent certain choice \mathcal G \mathcal H influence computational complexity observe problem polynomial-time solvable \mathcal H class path whereas NP-complete \mathcal G class path Moreover show problem even NP-complete many elementary graph class namely linear forest union complete graph cographs proper interval graph split graph tree pathwidth contrast prove problem fixed-parameter tractable k \mathcal G class tree \mathcal H class tree k leaf \mathcal G \mathcal H equal class graph vertex cover number k
paper study property prefix-primitive annihilator language catenation shuffle product bi-catenation operation prove every finite language L catenation operation left prefix-primitive annihilator L equal right prefix-primitive annihilator L left prefix-primitive annihilator language regular finite language left prefix-primitive annihilator thin language empty Moreover also characterize prefix-primitive annihilator non-empty language shuffle product bi-catenation operation alphabet two letter paper study property prefix-primitive annihilator language catenation shuffle product bi-catenation operation prove every finite language L catenation operation left prefix-primitive annihilator L equal right prefix-primitive annihilator L left prefix-primitive annihilator language regular finite language left prefix-primitive annihilator thin language empty Moreover also characterize prefix-primitive annihilator non-empty language shuffle product bi-catenation operation alphabet two letter
give axiom operation describes iteration various relational model computation model differ treatment finite infinite aborting execution covering partial total general correctness extension thereof Based common axiom derive separation refinement program transformation result hitherto known particular model henceforth recognised hold many different model introduce new model independently describes finite infinite aborting execution computation axiomatise operation extract infinite execution model others From unifying axiom derive explicit representation recursion iteration show also new model instance general theory iteration All result verified Isabelle heavily using automated theorem provers give axiom operation describes iteration various relational model computation model differ treatment finite infinite aborting execution covering partial total general correctness extension thereof Based common axiom derive separation refinement program transformation result hitherto known particular model henceforth recognised hold many different model introduce new model independently describes finite infinite aborting execution computation axiomatise operation extract infinite execution model others From unifying axiom derive explicit representation recursion iteration show also new model instance general theory iteration All result verified Isabelle heavily using automated theorem provers
derive variety result algorithmics switch graph On negative side prove hardness following problem Given switch graph posse bipartite/planar/triangle-free/Eulerian configuration ? On positive side design fast algorithm several connectivity problem undirected switch graph recognizing acyclic configuration directed switch graph derive variety result algorithmics switch graph On negative side prove hardness following problem Given switch graph posse bipartite/planar/triangle-free/Eulerian configuration ? On positive side design fast algorithm several connectivity problem undirected switch graph recognizing acyclic configuration directed switch graph
Model checking tool face combinatorial blow state-space commonly known state explosion problem must addressed formally verify concurrent system propose approach combining abstraction technique heuristic search overcome problem particular heuristic search avoid bottleneck exhaustive exploration global state graph system retaining advantage abstraction technique Model checking tool face combinatorial blow state-space commonly known state explosion problem must addressed formally verify concurrent system propose approach combining abstraction technique heuristic search overcome problem particular heuristic search avoid bottleneck exhaustive exploration global state graph system retaining advantage abstraction technique
address problem alternating simulation refinement concurrent timed game TG show checking timed alternating simulation TG EXPTIME-complete provide logical characterization preorder term meaningful fragment new logic TAMTL* TAMTL* action-based timed extension standard alternating-time temporal logic ATL* allows quantify strategy designated coalition player responsible blocking time While full TAMTL* model-checking TG undecidable show fragment TAMTL corresponding timed version ATL problem instead decidable EXPTIME address problem alternating simulation refinement concurrent timed game TG show checking timed alternating simulation TG EXPTIME-complete provide logical characterization preorder term meaningful fragment new logic TAMTL* TAMTL* action-based timed extension standard alternating-time temporal logic ATL* allows quantify strategy designated coalition player responsible blocking time While full TAMTL* model-checking TG undecidable show fragment TAMTL corresponding timed version ATL problem instead decidable EXPTIME
Stochastic game logic SGL new temporal logic multi-agent system modeled turn-based multi-player game discrete transition probability It combine feature alternating-time temporal logic ATL probabilistic computation tree logic extended temporal logic SGL contains ATL-like modality specify individual cooperation reaction facility agent multi-player game enforce certain winning objective While standard ATL modality state existence strategy certain coalition agent without restricting range strategy semantics inner SGL formula deal general modality It also requires existence strategy coalition imposes kind strategy binding inner SGL formula paper present syntax semantics SGL discus model checking problem different type strategy model checking problem SGL turn undecidable dealing full class history-dependent strategy show SGL model checking problem memoryless deterministic strategy well model checking problem qualitative fragment SGL memoryless randomized strategy PSPACE-complete establish close link natural syntactic fragment SGL polynomial hierarchy Further give reduction SGL model checking problem memoryless randomized strategy Tarski algebra prof problem EXPSPACE Stochastic game logic SGL new temporal logic multi-agent system modeled turn-based multi-player game discrete transition probability It combine feature alternating-time temporal logic ATL probabilistic computation tree logic extended temporal logic SGL contains ATL-like modality specify individual cooperation reaction facility agent multi-player game enforce certain winning objective While standard ATL modality state existence strategy certain coalition agent without restricting range strategy semantics inner SGL formula deal general modality It also requires existence strategy coalition imposes kind strategy binding inner SGL formula paper present syntax semantics SGL discus model checking problem different type strategy model checking problem SGL turn undecidable dealing full class history-dependent strategy show SGL model checking problem memoryless deterministic strategy well model checking problem qualitative fragment SGL memoryless randomized strategy PSPACE-complete establish close link natural syntactic fragment SGL polynomial hierarchy Further give reduction SGL model checking problem memoryless randomized strategy Tarski algebra prof problem EXPSPACE
characterization class FO [ ] -definable language generating recognizing device still open problem prove restricted word bounded language class coincides class semilinear language also study closure property class language definable FO [ +1 ] FO [ < ] FO [ ] FOC [ ] main classical operation characterization class FO [ ] -definable language generating recognizing device still open problem prove restricted word bounded language class coincides class semilinear language also study closure property class language definable FO [ +1 ] FO [ < ] FO [ ] FOC [ ] main classical operation
Tree pattern represent important fragment XPath paper show class \mathcal C tree pattern exhibit property given finite number compatible tree pattern P_1 \ldots P_n\in \mathcal C exists another pattern P P P n contained P tree pattern Q\in \mathcal C P P n contained Q P contained Q experimentally demonstrate pattern P usually much smaller P P n combined together Using existence P show testing whether tree pattern P contained another Q\in \mathcal C acyclic schema graph G reduced testing whether P G transformed version P contained Q without schema graph provided distinguished node P labeled * show G maximal contained rewriting MCR tree pattern Q using view V found finding MCR Q using V G without G *-nodes distinguished path V *-nodes Q Tree pattern represent important fragment XPath paper show class \mathcal C tree pattern exhibit property given finite number compatible tree pattern P_1 \ldots P_n\in \mathcal C exists another pattern P P P n contained P tree pattern Q\in \mathcal C P P n contained Q P contained Q experimentally demonstrate pattern P usually much smaller P P n combined together Using existence P show testing whether tree pattern P contained another Q\in \mathcal C acyclic schema graph G reduced testing whether P G transformed version P contained Q without schema graph provided distinguished node P labeled * show G maximal contained rewriting MCR tree pattern Q using view V found finding MCR Q using V G without G *-nodes distinguished path V *-nodes Q
study new application coinduction namely escalation typical feature infinite game Therefore tool conceived studying infinite mathematical structure namely deriving coinduction essential Here use coinduction backward coinduction show connection concept finite game study carefully formally infinite game especially so-called dollar auction considered paradigm escalation Unlike commonly admitted show provided one assumes agent always stop bidding rational result subgame perfect equilibrium show rational strategy profile subgame perfect equilibrium Indeed agent stop stop every step claim rational well one admits opponent never stop corresponds subgame perfect equilibrium Amazingly infinite dollar auction game behavior agent stop step Nash equilibrium hence subgame perfect equilibrium hence rational right notion rationality obtain fit common sense experience remove feeling paradox study new application coinduction namely escalation typical feature infinite game Therefore tool conceived studying infinite mathematical structure namely deriving coinduction essential Here use coinduction backward coinduction show connection concept finite game study carefully formally infinite game especially so-called dollar auction considered paradigm escalation Unlike commonly admitted show provided one assumes agent always stop bidding rational result subgame perfect equilibrium show rational strategy profile subgame perfect equilibrium Indeed agent stop stop every step claim rational well one admits opponent never stop corresponds subgame perfect equilibrium Amazingly infinite dollar auction game behavior agent stop step Nash equilibrium hence subgame perfect equilibrium hence rational right notion rationality obtain fit common sense experience remove feeling paradox
Instruction sequence key concept practice yet come prominently picture theoretical circle paper concern instruction sequence behaviour produced execution interaction behaviour component execution environment two issue relating computability theory Positioning Turing � result regarding undecidability halting problem result program rather machine taking instruction sequence program analyse autosolvability requirement program certain kind must solve halting problem program kind present novel result concerning autosolvability requirement analysis streamlined using notion functional unit abstract state-based model machine case behaviour exhibited component execution environment viewed behaviour machine different state behaviour concerned completely determined functional unit above-mentioned analysis involves functional unit whose possible state represent possible content tape Turing machine particular tape alphabet also investigate functional unit whose possible state natural number investigation yield novel computability result viz existence universal computable functional unit natural number Instruction sequence key concept practice yet come prominently picture theoretical circle paper concern instruction sequence behaviour produced execution interaction behaviour component execution environment two issue relating computability theory Positioning Turing � result regarding undecidability halting problem result program rather machine taking instruction sequence program analyse autosolvability requirement program certain kind must solve halting problem program kind present novel result concerning autosolvability requirement analysis streamlined using notion functional unit abstract state-based model machine case behaviour exhibited component execution environment viewed behaviour machine different state behaviour concerned completely determined functional unit above-mentioned analysis involves functional unit whose possible state represent possible content tape Turing machine particular tape alphabet also investigate functional unit whose possible state natural number investigation yield novel computability result viz existence universal computable functional unit natural number
present paper study nonterminal complexity one-sided random context grammar More specifically prove every recursively enumerable language generated one-sided random context grammar ten nonterminals An analogical result hold thirteen nonterminals term grammar set left random context rule coinciding set right random context rule Furthermore introduce notion right random context nonterminal defined nonterminal appears left-hand side right random context rule demonstrate convert one-sided random context grammar G equivalent one-sided random context grammar H two right random context nonterminals An analogical conversion given term propagating one-sided random context grammar left random context nonterminals conclusion two open problem stated present paper study nonterminal complexity one-sided random context grammar More specifically prove every recursively enumerable language generated one-sided random context grammar ten nonterminals An analogical result hold thirteen nonterminals term grammar set left random context rule coinciding set right random context rule Furthermore introduce notion right random context nonterminal defined nonterminal appears left-hand side right random context rule demonstrate convert one-sided random context grammar G equivalent one-sided random context grammar H two right random context nonterminals An analogical conversion given term propagating one-sided random context grammar left random context nonterminals conclusion two open problem stated
Finitely generated bi-ideals letter selected alphabet considered solve equivalence problem generating system bi-ideals i.e look effective procedure provides mean determining two generating system \langle u_0 u_ m-1 \rangle \langle v_0 v_ n-1 \rangle represent equal different bi-ideals offer method constructing every generating system \langle u_0 u_ m-1 \rangle equivalent generating system \langle u^ \prime u^ \prime m-1 \rangle differing member also describe algorithm deciding two generating system \langle u_0 u_1 \rangle \langle v_0 v_1 \rangle equivalent For general case problem existence algorithm remains open Finitely generated bi-ideals letter selected alphabet considered solve equivalence problem generating system bi-ideals i.e look effective procedure provides mean determining two generating system \langle u_0 u_ m-1 \rangle \langle v_0 v_ n-1 \rangle represent equal different bi-ideals offer method constructing every generating system \langle u_0 u_ m-1 \rangle equivalent generating system \langle u^ \prime u^ \prime m-1 \rangle differing member also describe algorithm deciding two generating system \langle u_0 u_1 \rangle \langle v_0 v_1 \rangle equivalent For general case problem existence algorithm remains open
revise accordance preorder context deadlock freedom asynchronously communicating service Accordance considers controller service�that environment interact service without deadlocking service Impl accord service Spec every controller Spec also controller Impl model finite-state infinite-state service Petri net formalize semantics model traditional concurrency semantics trace-based semantics benefit get easier characterization accordance preorder prove fully abstract precongruence present algorithm decide refinement two finite-state service Previously operating guideline introduced study behavior finite-state service characterize controller given service used decide accordance An operating guideline finite automaton annotated Boolean formula describes semantics service perspective controller rather perspective service show trace-based semantics translated back forth operating guideline thereby providing conceptual understanding operating guideline revise accordance preorder context deadlock freedom asynchronously communicating service Accordance considers controller service�that environment interact service without deadlocking service Impl accord service Spec every controller Spec also controller Impl model finite-state infinite-state service Petri net formalize semantics model traditional concurrency semantics trace-based semantics benefit get easier characterization accordance preorder prove fully abstract precongruence present algorithm decide refinement two finite-state service Previously operating guideline introduced study behavior finite-state service characterize controller given service used decide accordance An operating guideline finite automaton annotated Boolean formula describes semantics service perspective controller rather perspective service show trace-based semantics translated back forth operating guideline thereby providing conceptual understanding operating guideline
consider system equation weighted tree transformation finite support continuous commutative semirings define weighted relation equational component least solution system equation pair algebra particular focus equational weighted tree transformation equational relation obtained considering least solution system pair term algebra characterize equational weighted tree transformation term weighted tree transformation defined different weighted bimorphisms demonstrate robustness equational weighted tree transformation give equational definition class linear nondeleting weighted top-down tree transformation class linear nondeleting weighted extended top-down tree transformation Finally prove weighted relation equational roughly speaking morphic image weighted equational tree transformation consider system equation weighted tree transformation finite support continuous commutative semirings define weighted relation equational component least solution system equation pair algebra particular focus equational weighted tree transformation equational relation obtained considering least solution system pair term algebra characterize equational weighted tree transformation term weighted tree transformation defined different weighted bimorphisms demonstrate robustness equational weighted tree transformation give equational definition class linear nondeleting weighted top-down tree transformation class linear nondeleting weighted extended top-down tree transformation Finally prove weighted relation equational roughly speaking morphic image weighted equational tree transformation
study problem scheduling unit execution time job release date precedence constraint two identical processor say schedule ideal minimizes maximum total completion time simultaneously give instance problem min-max completion time exceeded every preemptive schedule minimizes total completion time instance even precedence constraint form intree prof ideal schedule exist general preemption allowed On hand prove preemption allowed ideal schedule exist general precedence constraint provide algorithm finding ideal schedule O n time n number job finding ideal schedule resolve conjecture Baptiste Timkovsky Math Methods Oper Res 60 :145�153 2004 Further algorithm finding min-max completion-time schedule requires O n time efficient solution date required O n time study problem scheduling unit execution time job release date precedence constraint two identical processor say schedule ideal minimizes maximum total completion time simultaneously give instance problem min-max completion time exceeded every preemptive schedule minimizes total completion time instance even precedence constraint form intree prof ideal schedule exist general preemption allowed On hand prove preemption allowed ideal schedule exist general precedence constraint provide algorithm finding ideal schedule O n time n number job finding ideal schedule resolve conjecture Baptiste Timkovsky Math Methods Oper Res 60 :145�153 2004 Further algorithm finding min-max completion-time schedule requires O n time efficient solution date required O n time
transition set semantics Wang Jiao LNCS 6128:84�103 2010 partition Petri net behavior canonical way behavior equivalence class canonical transition set sequence article extends semantics two way firstly semantics parameterized basic relation structural transition define different variant secondly semantics infinite firing sequence net defined prove extension still preserve well-definedness soundness completeness semantics Furthermore show recognize infinite sequence called back-loops view new semantics transition set semantics Wang Jiao LNCS 6128:84�103 2010 partition Petri net behavior canonical way behavior equivalence class canonical transition set sequence article extends semantics two way firstly semantics parameterized basic relation structural transition define different variant secondly semantics infinite firing sequence net defined prove extension still preserve well-definedness soundness completeness semantics Furthermore show recognize infinite sequence called back-loops view new semantics
Mutual mobile membrane system represent variant mobile membrane system endocytosis exocytosis work whenever involved membrane � agree � movement using mutual complement object placed membrane provide semi-uniform polynomial solution weak NP-complete problem namely partition problem mean mutual mobile membrane system Mutual mobile membrane system represent variant mobile membrane system endocytosis exocytosis work whenever involved membrane � agree � movement using mutual complement object placed membrane provide semi-uniform polynomial solution weak NP-complete problem namely partition problem mean mutual mobile membrane system
paper present algebraic compilation approach correct synthesis compilation hardware synchronous language shared variable parallelism synthesis process generates hardware component implement source program mean gradually reducing highly parallel state-machine correctness compiler follows construction correctness transformation involved synthesis process Each transformation proved sound basic algebraic law source language law formally derived denotational semantics expressed Unified Theories Programming proposed approach based previous effort handle software hardware compilation pure algebraic style complexity source language demanded significant adaptation extension existing approach paper present algebraic compilation approach correct synthesis compilation hardware synchronous language shared variable parallelism synthesis process generates hardware component implement source program mean gradually reducing highly parallel state-machine correctness compiler follows construction correctness transformation involved synthesis process Each transformation proved sound basic algebraic law source language law formally derived denotational semantics expressed Unified Theories Programming proposed approach based previous effort handle software hardware compilation pure algebraic style complexity source language demanded significant adaptation extension existing approach
establish existence optimal scheduling strategy time-bounded reachability continuous-time Markov decision process co-optimal strategy continuous-time Markov game Furthermore show optimal control exist surprisingly simple structure optimal scheduler proof deterministic timed positional bounded time divided finite number interval optimal strategy positional That demonstrate existence finite optimal control Finally show pleasant property Markov decision process extend general class continuous-time Markov game early late scheduler show behaviour establish existence optimal scheduling strategy time-bounded reachability continuous-time Markov decision process co-optimal strategy continuous-time Markov game Furthermore show optimal control exist surprisingly simple structure optimal scheduler proof deterministic timed positional bounded time divided finite number interval optimal strategy positional That demonstrate existence finite optimal control Finally show pleasant property Markov decision process extend general class continuous-time Markov game early late scheduler show behaviour
Behavioral model capture operational principle real-world designed system Formally behavioral model defines state space system i.e state principle state transition Such model basis analysis system � property practice state space system immense result huge computational complexity analysis Behavioral model typically described executable graph whose execution semantics encodes state space structure theory behavioral model study relation structure model property state space article use connectivity property graph achieve efficient extensive discovery compositional structure behavioral model behavioral model get stepwise decomposed component clear structural characteristic inter-component relation At decomposition step discovered compositional structure model used reasoning property whole state space system approach exemplified mean concrete behavioral model verification criterion That analyze workflow net well-established tool modeling behavior distributed system respect soundness property basic correctness property workflow net Stepwise verification allows detection violation soundness property inspecting small portion model thereby considerably reducing amount work done perform soundness check Besides formal result also report finding applying approach industry model collection Behavioral model capture operational principle real-world designed system Formally behavioral model defines state space system i.e state principle state transition Such model basis analysis system � property practice state space system immense result huge computational complexity analysis Behavioral model typically described executable graph whose execution semantics encodes state space structure theory behavioral model study relation structure model property state space article use connectivity property graph achieve efficient extensive discovery compositional structure behavioral model behavioral model get stepwise decomposed component clear structural characteristic inter-component relation At decomposition step discovered compositional structure model used reasoning property whole state space system approach exemplified mean concrete behavioral model verification criterion That analyze workflow net well-established tool modeling behavior distributed system respect soundness property basic correctness property workflow net Stepwise verification allows detection violation soundness property inspecting small portion model thereby considerably reducing amount work done perform soundness check Besides formal result also report finding applying approach industry model collection
Inspired need performability model HSDPA user equipment Markovian queue varying number server conceived arrival service process number allocated active server queue inherently independently jointly Markov modulated Batch arrival batch service autocorrelation inter-arrival time autocorrelation batch size accommodated queue suitable use Markov modulation generalized exponential distribution queue provision negative customer Transformations balance equation computable form proposed order obtain steady state probability Spectral Expansion method queue used model High Speed Downlink Packet Access HSDPA wireless network model integrated one respect HSDPA capable accommodating many intricate aspect HSDPA channel allocation policy loss packet due channel fading bursty correlated traffic Good agreement observed numerical result proposed analytical model independent simulator real HSDPA radio channel behavior comparison terminal category specified 3rd Generation Partnership Project 3GPP also presented Inspired need performability model HSDPA user equipment Markovian queue varying number server conceived arrival service process number allocated active server queue inherently independently jointly Markov modulated Batch arrival batch service autocorrelation inter-arrival time autocorrelation batch size accommodated queue suitable use Markov modulation generalized exponential distribution queue provision negative customer Transformations balance equation computable form proposed order obtain steady state probability Spectral Expansion method queue used model High Speed Downlink Packet Access HSDPA wireless network model integrated one respect HSDPA capable accommodating many intricate aspect HSDPA channel allocation policy loss packet due channel fading bursty correlated traffic Good agreement observed numerical result proposed analytical model independent simulator real HSDPA radio channel behavior comparison terminal category specified 3rd Generation Partnership Project 3GPP also presented
notion one-sided random context grammar defined context-free-based regulated grammar set permitting symbol set forbidding symbol attached every rule set rule divided set left random context rule set right random context rule left random context rule rewrite nonterminal permitting symbol occurs left rewritten symbol current sentential form forbidding symbol occur right random context rule applied analogically except symbol examined right rewritten symbol paper demonstrates without erasing rule one-sided random context grammar characterize family context-sensitive language erasing rule grammar characterize family recursively enumerable language fact characterization result hold even set left random context rule coincides set right random context rule Several special case grammar considered generative power established conclusion important open problem suggested study future notion one-sided random context grammar defined context-free-based regulated grammar set permitting symbol set forbidding symbol attached every rule set rule divided set left random context rule set right random context rule left random context rule rewrite nonterminal permitting symbol occurs left rewritten symbol current sentential form forbidding symbol occur right random context rule applied analogically except symbol examined right rewritten symbol paper demonstrates without erasing rule one-sided random context grammar characterize family context-sensitive language erasing rule grammar characterize family recursively enumerable language fact characterization result hold even set left random context rule coincides set right random context rule Several special case grammar considered generative power established conclusion important open problem suggested study future
Free theorem establish interesting property parametrically polymorphic function solely type serve nice proof tool For pure lazy functional programming language used precondition Unfortunately presence selective strictness provided language like Haskell original strength reduced paper present approach overcoming weakness specific situation Employing refined type system track use enforced strict evaluation rule unnecessary restriction otherwise emerge Additionally provide implement algorithm determining refined type given term Free theorem establish interesting property parametrically polymorphic function solely type serve nice proof tool For pure lazy functional programming language used precondition Unfortunately presence selective strictness provided language like Haskell original strength reduced paper present approach overcoming weakness specific situation Employing refined type system track use enforced strict evaluation rule unnecessary restriction otherwise emerge Additionally provide implement algorithm determining refined type given term
simple mutual exclusion algorithm presented us nonatomic shared variable bounded size satisfies bounded overtaking When shared variable behave atomically first-come-first-served property FCFS Nonatomic access make information vulnerable effect mitigated minimizing information spreading variable design approach adopted begin mitigating effort These resulted algorithm proof correctness first atomic variable proof used blueprint simultaneous development algorithm nonatomic variable proof Mutual exclusion proved mean invariant Bounded overtaking liveness weak fairness proved invariant variant function Liveness weak fairness formalized proved set-theoretic version temporal logic All assertion verified proof assistant PVS heavily rely possibility offered proof assistant like PVS reuse proof developed one context different context simple mutual exclusion algorithm presented us nonatomic shared variable bounded size satisfies bounded overtaking When shared variable behave atomically first-come-first-served property FCFS Nonatomic access make information vulnerable effect mitigated minimizing information spreading variable design approach adopted begin mitigating effort These resulted algorithm proof correctness first atomic variable proof used blueprint simultaneous development algorithm nonatomic variable proof Mutual exclusion proved mean invariant Bounded overtaking liveness weak fairness proved invariant variant function Liveness weak fairness formalized proved set-theoretic version temporal logic All assertion verified proof assistant PVS heavily rely possibility offered proof assistant like PVS reuse proof developed one context different context
Circus combine construct define complex data operation interaction integrates Z CSP distinctively language refinement describe program well specification design model semantics based unifying theory programming UTP Most importantly Circus representative class refinement-oriented language combine facility specify abstract data type model-based style pattern interaction What present Circus testing theory work relevant foundation sound test-generation technique plethora state-rich reactive language cater data operation define symbolic test exhaustive test set They basis test-generation technique combine coverage criterion data transition model notion correctness Circus refinement UTP-based generalisation failures-divergences refinement considers data modelling Proof exhaustivity exploit correspondence operational denotational semantics Circus combine construct define complex data operation interaction integrates Z CSP distinctively language refinement describe program well specification design model semantics based unifying theory programming UTP Most importantly Circus representative class refinement-oriented language combine facility specify abstract data type model-based style pattern interaction What present Circus testing theory work relevant foundation sound test-generation technique plethora state-rich reactive language cater data operation define symbolic test exhaustive test set They basis test-generation technique combine coverage criterion data transition model notion correctness Circus refinement UTP-based generalisation failures-divergences refinement considers data modelling Proof exhaustivity exploit correspondence operational denotational semantics
propose abstract observation table abstract data type learning deterministic weighted tree automaton Angluin � minimal adequate teacher MAT model show every correct implementation abstract observation table yield correct MAT learner Besides � classical � observation table show abstract observation table also implemented observation tree advantage latter often require fewer query teacher propose abstract observation table abstract data type learning deterministic weighted tree automaton Angluin � minimal adequate teacher MAT model show every correct implementation abstract observation table yield correct MAT learner Besides � classical � observation table show abstract observation table also implemented observation tree advantage latter often require fewer query teacher
study D0L power series arbitrary field characterize D0L power series also rational series consequence show rationality decidable D0L power series many field study D0L power series arbitrary field characterize D0L power series also rational series consequence show rationality decidable D0L power series many field
note show number equivalence query asked algorithm proposed Becerra-Bonache et al Proceedings 8th International Colloquium Grammatical Inference ICGI � 06 Lecture Notes Artificial Intelligence Springer-Verlag Berlin 2006 learns deterministic finite automaton correction equivalence query injectivity degree target language notion corresponds number repetition among correcting word element quotient language Myhill-Nerode equivalence Further propose tight upper bound number correction query function depends index target language length longest counterexample returned teacher injectivity degree target language However bound obtained number CQs optimal LCA algorithm represent tight upper bound DFA learning EQs CQs general note show number equivalence query asked algorithm proposed Becerra-Bonache et al Proceedings 8th International Colloquium Grammatical Inference ICGI � 06 Lecture Notes Artificial Intelligence Springer-Verlag Berlin 2006 learns deterministic finite automaton correction equivalence query injectivity degree target language notion corresponds number repetition among correcting word element quotient language Myhill-Nerode equivalence Further propose tight upper bound number correction query function depends index target language length longest counterexample returned teacher injectivity degree target language However bound obtained number CQs optimal LCA algorithm represent tight upper bound DFA learning EQs CQs general
problem classifying avoidable binary pattern full word completely solved see Chap M. Lothaire Algebraic Combinatorics Words Cambridge University Press 2002 paper classify avoidable binary pattern partial word sequence may undefined position called hole particular show substitute variable pattern partial word consisting one hole avoidability index pattern remains full word case problem classifying avoidable binary pattern full word completely solved see Chap M. Lothaire Algebraic Combinatorics Words Cambridge University Press 2002 paper classify avoidable binary pattern partial word sequence may undefined position called hole particular show substitute variable pattern partial word consisting one hole avoidability index pattern remains full word case
paper present clustering Clustering partition record cluster record within cluster similar record different cluster distinct one another based k-anonymization technique minimize information loss time assuring data quality Privacy preservation individual drawn considerable interest data mining research k-anonymity model proposed Samarati Sweeney practical approach data privacy preservation studied extensively last year Anonymization method via generalization suppression able protect private information lose valued information challenge minimize information loss anonymization process refer challenge systematic clustering problem k-anonymization analysed paper proposed technique adopts group-similar data together anonymizes group individually structure systematic clustering problem defined investigated paradigm property An algorithm proposed problem developed shown time complexity O \frac n^ k n total number record containing individual concerning privacy Experimental result show method attains reasonable dominance respect information loss execution time Finally algorithm illustrates usability incremental datasets paper present clustering Clustering partition record cluster record within cluster similar record different cluster distinct one another based k-anonymization technique minimize information loss time assuring data quality Privacy preservation individual drawn considerable interest data mining research k-anonymity model proposed Samarati Sweeney practical approach data privacy preservation studied extensively last year Anonymization method via generalization suppression able protect private information lose valued information challenge minimize information loss anonymization process refer challenge systematic clustering problem k-anonymization analysed paper proposed technique adopts group-similar data together anonymizes group individually structure systematic clustering problem defined investigated paradigm property An algorithm proposed problem developed shown time complexity O \frac n^ k n total number record containing individual concerning privacy Experimental result show method attains reasonable dominance respect information loss execution time Finally algorithm illustrates usability incremental datasets
paper study algebraic property concerning prefix primitive word p-primitive conjugate related primitive word considered characterize d-primitive square-free word non-p-primitive conjugate also study algebraic property annihilator concerning p-primitive word paper study algebraic property concerning prefix primitive word p-primitive conjugate related primitive word considered characterize d-primitive square-free word non-p-primitive conjugate also study algebraic property annihilator concerning p-primitive word
transition stateless automaton depend internal state solely symbol currently scanned head accessing input memory investigate stateless deterministic restarting automaton executing rewrite step continue read tape performing restart Even weakest class thus obtained contains regular language properly relation different class stateless automaton well stateless automaton corresponding type automaton state investigated shown language class defined various type deterministic stateless restarting automaton without auxiliary symbol anti-AFLs even closed reversal transition stateless automaton depend internal state solely symbol currently scanned head accessing input memory investigate stateless deterministic restarting automaton executing rewrite step continue read tape performing restart Even weakest class thus obtained contains regular language properly relation different class stateless automaton well stateless automaton corresponding type automaton state investigated shown language class defined various type deterministic stateless restarting automaton without auxiliary symbol anti-AFLs even closed reversal
paging algorithm Least Recently Used Second Last Request LRU-2 proposed use database disk buffering shown experimentally perform better Least Recently Used LRU compare LRU-2 LRU theoretically using standard competitive analysis newer relative worst order analysis competitive ratio LRU-2 shown 2k cache size k worse LRU � competitive ratio k. However using relative worst order analysis show LRU-2 LRU comparable LRU-2 � favor giving theoretical justification experimental result Many result LRU-2 also apply generalization Least Recently Used Kth Last Request paging algorithm Least Recently Used Second Last Request LRU-2 proposed use database disk buffering shown experimentally perform better Least Recently Used LRU compare LRU-2 LRU theoretically using standard competitive analysis newer relative worst order analysis competitive ratio LRU-2 shown 2k cache size k worse LRU � competitive ratio k. However using relative worst order analysis show LRU-2 LRU comparable LRU-2 � favor giving theoretical justification experimental result Many result LRU-2 also apply generalization Least Recently Used Kth Last Request
consider job scheduling game two uniformly related parallel machine link Jobs atomic player delay job completion time machine running private goal job minimize delay social goal minimize maximum delay job minimize makespan consider well known price anarchy well strong price anarchy show wide range speed ratio two measure different whereas speed ratio two measure give exact bound extend result model restricted assignment machine may initial load resulting job assigned machine show tight result variant consider job scheduling game two uniformly related parallel machine link Jobs atomic player delay job completion time machine running private goal job minimize delay social goal minimize maximum delay job minimize makespan consider well known price anarchy well strong price anarchy show wide range speed ratio two measure different whereas speed ratio two measure give exact bound extend result model restricted assignment machine may initial load resulting job assigned machine show tight result variant
study extends understanding two-element pure code Some characteristic different length two-element pure code studied It shown language pure code contains two distinct primitive word u v different length regular expression u v two distinct word u v primitive study extends understanding two-element pure code Some characteristic different length two-element pure code studied It shown language pure code contains two distinct primitive word u v different length regular expression u v two distinct word u v primitive
present scheme convert self-stabilizing algorithm use randomization following convergence self-stabilizing algorithm use randomization convergence thus reduce number random bit infinite number expected bounded number scheme applicable case exit local predicate node global consistency implied union local predicate demonstrate scheme token circulation algorithm Herman Infor Process Lett 35:63�67 1990 recent constant time Byzantine self-stabilizing clock synchronization algorithm Ben-Or Dolev Hoch Proceedings 27th Annual ACM SIGACT-SIGOPS symposium principle distributed computing PODC 2008 application scheme result first constant time Byzantine self-stabilizing clock synchronization algorithm eventually stop using random bit present scheme convert self-stabilizing algorithm use randomization following convergence self-stabilizing algorithm use randomization convergence thus reduce number random bit infinite number expected bounded number scheme applicable case exit local predicate node global consistency implied union local predicate demonstrate scheme token circulation algorithm Herman Infor Process Lett 35:63�67 1990 recent constant time Byzantine self-stabilizing clock synchronization algorithm Ben-Or Dolev Hoch Proceedings 27th Annual ACM SIGACT-SIGOPS symposium principle distributed computing PODC 2008 application scheme result first constant time Byzantine self-stabilizing clock synchronization algorithm eventually stop using random bit
Systems Data Management Timed Automata SDMTAs network communicating timed automaton structure store message function manipulate prove decidability reachability problem subclass SDMTAs assumes unbounded knowledge analyze expressiveness model considered subclass particular SDMTAs simulate Turing machine hence reachability problem general undecidable subclass reachability decidable endowed concept recognized language accepts language regular application model analyze variation Yahalom protocol Systems Data Management Timed Automata SDMTAs network communicating timed automaton structure store message function manipulate prove decidability reachability problem subclass SDMTAs assumes unbounded knowledge analyze expressiveness model considered subclass particular SDMTAs simulate Turing machine hence reachability problem general undecidable subclass reachability decidable endowed concept recognized language accepts language regular application model analyze variation Yahalom protocol
Loop powerful program construct classical computation power still exploited fully quantum computation exploitation power definitely requires deep understanding mechanism quantum loop program paper introduce general scheme quantum loop describe computational process function computed quantum loop defined denotational semantics weakest precondition semantics quantum loop given notion termination almost termination proposed quantum loop paper consider case finite-dimensional state space Necessary sufficient condition termination almost termination general quantum loop mixed input state presented quantum loop said almost terminating almost terminates input state show quantum loop almost terminating uniformly almost terminating It observed small disturbance either unitary transformation loop body measurement loop guard make quantum loop almost terminating provided dimension restriction satisfied Moreover representation function computed quantum loop given term finite summation matrix illustrate notion result obtained paper two simple class quantum loop program one qubit quantum loop two qubit quantum loop defined controlled gate carefully examined show expressive power quantum loop applied describing quantum walk Loop powerful program construct classical computation power still exploited fully quantum computation exploitation power definitely requires deep understanding mechanism quantum loop program paper introduce general scheme quantum loop describe computational process function computed quantum loop defined denotational semantics weakest precondition semantics quantum loop given notion termination almost termination proposed quantum loop paper consider case finite-dimensional state space Necessary sufficient condition termination almost termination general quantum loop mixed input state presented quantum loop said almost terminating almost terminates input state show quantum loop almost terminating uniformly almost terminating It observed small disturbance either unitary transformation loop body measurement loop guard make quantum loop almost terminating provided dimension restriction satisfied Moreover representation function computed quantum loop given term finite summation matrix illustrate notion result obtained paper two simple class quantum loop program one qubit quantum loop two qubit quantum loop defined controlled gate carefully examined show expressive power quantum loop applied describing quantum walk
article present local LR error repair method repair syntax error quickly adoption A* algorithm help remove unproductive configuration new method also enhances repair quality adoption flexible edit strategy support shifting symbol unrestrictedly well inserting deleting symbol order repair invalid input string Experimental result show new method excels existing work repair quality efficiency article present local LR error repair method repair syntax error quickly adoption A* algorithm help remove unproductive configuration new method also enhances repair quality adoption flexible edit strategy support shifting symbol unrestrictedly well inserting deleting symbol order repair invalid input string Experimental result show new method excels existing work repair quality efficiency
paper improve result regarding size complexity accepting hybrid network evolutionary processor AHNEPs show universal AHNEPs size devising method simulating 2-tag system result improves best upper bound size universal AHNEPs also propose computationally descriptionally efficient simulation nondeterministic Turing machine AHNEPs More precisely prove AHNEPs ten node simulate nondeterministic Turing machine time complexity f n time O f n result significantly improves best known upper bound number node network simulating linear time arbitrary Turing machine namely 24 paper improve result regarding size complexity accepting hybrid network evolutionary processor AHNEPs show universal AHNEPs size devising method simulating 2-tag system result improves best upper bound size universal AHNEPs also propose computationally descriptionally efficient simulation nondeterministic Turing machine AHNEPs More precisely prove AHNEPs ten node simulate nondeterministic Turing machine time complexity f n time O f n result significantly improves best known upper bound number node network simulating linear time arbitrary Turing machine namely 24
present relation-algebraic specification injective embedding mapping splittings partial equivalence relation show case axiom characterize construction isomorphism i.e essentially unique way Based specification develop relational program computing splitting demonstrate application example originate relation-algebraic treatment process graph theory decomposition specific relation present relation-algebraic specification injective embedding mapping splittings partial equivalence relation show case axiom characterize construction isomorphism i.e essentially unique way Based specification develop relational program computing splitting demonstrate application example originate relation-algebraic treatment process graph theory decomposition specific relation
apply powerful proof-techniques concurrency theory study observational theory Thielecke � CPS-calculus distillation target language Continuation-Passing Style transforms define labelled transition system derive weak labelled bisimilarity completely characterises Morris � context-equivalence prove context lemma showing Morris � context-equivalence coincides simpler context-equivalence closed smaller class context Then profit determinism CPS-calculus give simpler labelled characterisation Morris � equivalence style Abramsky � applicative bisimilarity enhance bisimulation proof-methods bisimilarity context proof technique use bisimulation proof technique investigate algebraic property diverging term proved using original axiomatic semantics CPS-calculus apply powerful proof-techniques concurrency theory study observational theory Thielecke � CPS-calculus distillation target language Continuation-Passing Style transforms define labelled transition system derive weak labelled bisimilarity completely characterises Morris � context-equivalence prove context lemma showing Morris � context-equivalence coincides simpler context-equivalence closed smaller class context Then profit determinism CPS-calculus give simpler labelled characterisation Morris � equivalence style Abramsky � applicative bisimilarity enhance bisimulation proof-methods bisimilarity context proof technique use bisimulation proof technique investigate algebraic property diverging term proved using original axiomatic semantics CPS-calculus
paper introduce new M/M/1 retrial queue working vacation motivated performance analysis Media Access Control function wireless system give condition stability model important impact setting retrial rate system derive closed form solution equilibrium retrial M/M/1 queue working vacation also show conditional stochastic decomposition hold model well paper introduce new M/M/1 retrial queue working vacation motivated performance analysis Media Access Control function wireless system give condition stability model important impact setting retrial rate system derive closed form solution equilibrium retrial M/M/1 queue working vacation also show conditional stochastic decomposition hold model well
paper describes verification framework Hoare-style pre- post-conditions program manipulating balanced tree-like data structure Since considered verification problem undecidable appeal standard semi-algorithmic approach user provide loop invariant automatically checked together program pre- post-conditions specify set program state representing tree-like memory configuration using Tree Automata Size Constraints TASC main advantage new class tree automaton recognise tree language based arithmetic reasoning length various possibly path tree like AVL tree red�black tree TASCs closed union intersection complement emptiness problem decidable Thus obtain class automaton interesting theoretical contribution Further show restriction one automatically compute effect tree-updating program statement set configuration represented TASC make TASC practical verification tool tried approach insertion procedure red�black tree verified output arbitrary balanced red�black tree also balanced red�black tree paper describes verification framework Hoare-style pre- post-conditions program manipulating balanced tree-like data structure Since considered verification problem undecidable appeal standard semi-algorithmic approach user provide loop invariant automatically checked together program pre- post-conditions specify set program state representing tree-like memory configuration using Tree Automata Size Constraints TASC main advantage new class tree automaton recognise tree language based arithmetic reasoning length various possibly path tree like AVL tree red�black tree TASCs closed union intersection complement emptiness problem decidable Thus obtain class automaton interesting theoretical contribution Further show restriction one automatically compute effect tree-updating program statement set configuration represented TASC make TASC practical verification tool tried approach insertion procedure red�black tree verified output arbitrary balanced red�black tree also balanced red�black tree
Rebeca actor-based language formal semantics suitable modeling concurrent distributed system protocol Due object model partial order symmetry detection reduction technique efficiently applied dynamic Rebeca model present two approach detecting symmetry Rebeca model One detects symmetry topology inter-connections among object another one exploit specific data structure reflect internal symmetry internal structure object former approach novel require input modeler deal dynamic change topology approach potentially applicable wide range modeling language distributed reactive system also developed model checking tool implement above-mentioned technique evaluation result show significant improvement model size model-checking time Rebeca actor-based language formal semantics suitable modeling concurrent distributed system protocol Due object model partial order symmetry detection reduction technique efficiently applied dynamic Rebeca model present two approach detecting symmetry Rebeca model One detects symmetry topology inter-connections among object another one exploit specific data structure reflect internal symmetry internal structure object former approach novel require input modeler deal dynamic change topology approach potentially applicable wide range modeling language distributed reactive system also developed model checking tool implement above-mentioned technique evaluation result show significant improvement model size model-checking time
Extended multi bottom�up tree transducer defined investigated They extension multi bottom�up tree transducer arbitrary shallow left-hand side rule includes rule consume input It shown transducer even linear one compute transformation computed linear extended top�down tree transducer theoretical model syntax-based machine translation Moreover classical composition result bottom�up tree transducer generalized extended multi bottom�up tree transducer Finally characterization term extended top�down tree transducer tree bimorphisms presented Extended multi bottom�up tree transducer defined investigated They extension multi bottom�up tree transducer arbitrary shallow left-hand side rule includes rule consume input It shown transducer even linear one compute transformation computed linear extended top�down tree transducer theoretical model syntax-based machine translation Moreover classical composition result bottom�up tree transducer generalized extended multi bottom�up tree transducer Finally characterization term extended top�down tree transducer tree bimorphisms presented
Traditional Earley parser operate two phase first recognizing input constructing forest parse tree Practically speaking quirk make awkward use compiler-compiler semantic action attached rule executed fact address problem identifying safe Earley set point recognition phase partial parse tree constructed mean semantic action may executed fly secondary benefit Earley set deleted recognition resulting substantial saving space time Traditional Earley parser operate two phase first recognizing input constructing forest parse tree Practically speaking quirk make awkward use compiler-compiler semantic action attached rule executed fact address problem identifying safe Earley set point recognition phase partial parse tree constructed mean semantic action may executed fly secondary benefit Earley set deleted recognition resulting substantial saving space time
synchronization problem investigated new class deterministic automaton called strongly transitive An extension unambiguous automaton also considered synchronization problem investigated new class deterministic automaton called strongly transitive An extension unambiguous automaton also considered
For synthesising efficient asynchronous circuit one deal state space explosion problem order alleviate problem one decompose STG smaller component paper deal decomposition method Vogler Wollowski introduces several strategy efficient implementation Furthermore approach combined another method alleviate state space explosion based Petri net unfolding developed algorithm compared mean benchmark example experimental result show significant improvement term memory usage runtime compared existing method For synthesising efficient asynchronous circuit one deal state space explosion problem order alleviate problem one decompose STG smaller component paper deal decomposition method Vogler Wollowski introduces several strategy efficient implementation Furthermore approach combined another method alleviate state space explosion based Petri net unfolding developed algorithm compared mean benchmark example experimental result show significant improvement term memory usage runtime compared existing method
Inspired recent work Meduna deep pushdown automaton consider computational power class basic program scheme NPSDS based around assignment while-loops non-deterministic guessing access deep pushdown stack apart usual push pop instruction also deep-push instruction allow element pushed stack location deep within stack syntactically define sub-classes NPSDS restricting occurrence pop push deep-pushes capture complexity class NP PSPACE Furthermore show problem accepted program scheme NPSDS EXPTIME Inspired recent work Meduna deep pushdown automaton consider computational power class basic program scheme NPSDS based around assignment while-loops non-deterministic guessing access deep pushdown stack apart usual push pop instruction also deep-push instruction allow element pushed stack location deep within stack syntactically define sub-classes NPSDS restricting occurrence pop push deep-pushes capture complexity class NP PSPACE Furthermore show problem accepted program scheme NPSDS EXPTIME
theory formal string language formal tree language important part theory formal language Regular tree language recognized finite tree automaton Trees postfix notation seen string paper present simple transformation given bottom-up finite tree automaton recognizing regular tree language deterministic pushdown automaton accepting tree language postfix notation resulting deterministic pushdown automaton implemented easily existing parser generator constructed LR grammar size directly corresponds size deterministic finite tree automaton class regular tree language postfix notation proper subclass deterministic context-free string language Moreover class tree language postfix notation deterministic context-free string language proper superclass class regular tree language theory formal string language formal tree language important part theory formal language Regular tree language recognized finite tree automaton Trees postfix notation seen string paper present simple transformation given bottom-up finite tree automaton recognizing regular tree language deterministic pushdown automaton accepting tree language postfix notation resulting deterministic pushdown automaton implemented easily existing parser generator constructed LR grammar size directly corresponds size deterministic finite tree automaton class regular tree language postfix notation proper subclass deterministic context-free string language Moreover class tree language postfix notation deterministic context-free string language proper superclass class regular tree language
Transformation XML data important task data exchange data publishing data integration Specifically data integration data XML source transformed match target schema Some source XML key defined When data transformed key also need transformed constraint comparison consistency checking unification target schema Thus key transformed whether transformed key valid preserved target schema important problem XML data transformation integration Towards problem firstly define XML key satisfaction study key transformed whether transformed key valid source schema transformed target schema Finally show whether transformed key satisfied transformed document Transformation XML data important task data exchange data publishing data integration Specifically data integration data XML source transformed match target schema Some source XML key defined When data transformed key also need transformed constraint comparison consistency checking unification target schema Thus key transformed whether transformed key valid preserved target schema important problem XML data transformation integration Towards problem firstly define XML key satisfaction study key transformed whether transformed key valid source schema transformed target schema Finally show whether transformed key satisfied transformed document
Control code concept closely related frequently occurring practitioner � view program code capable controlling behaviour machine present logical approach explain issue concerning control code independent detail behaviour controlled Using approach issue explained abstract level illustrate among thing mean example production new compiler existing one approach based abstract machine model called machine structure introduce model system provide execution environment executable code machine structure use go portability control code Control code concept closely related frequently occurring practitioner � view program code capable controlling behaviour machine present logical approach explain issue concerning control code independent detail behaviour controlled Using approach issue explained abstract level illustrate among thing mean example production new compiler existing one approach based abstract machine model called machine structure introduce model system provide execution environment executable code machine structure use go portability control code
consider optimal makespan C P arbitrary set P independent job scheduled preemption multiprocessor identical processor compare ratio makespans j preemption respectively < j ratio depends P interested P maximizes ratio i.e calculate formula worst case ratio G j defined G j =\max \frac C P C P j maximum taken set P independent job consider optimal makespan C P arbitrary set P independent job scheduled preemption multiprocessor identical processor compare ratio makespans j preemption respectively < j ratio depends P interested P maximizes ratio i.e calculate formula worst case ratio G j defined G j =\max \frac C P C P j maximum taken set P independent job
present formal semantics object-oriented specification language formal semantics presented conservative shallow embedding Isabelle/hol language oriented towards ocl formula context uml class diagram On basis formally derive several equational tableau calculus form basis integrated proof environment including automatic proof support support analysis type specification show application proof environment data refinement based adapted standard refinement notion Thus provide integrated formal method refinement-based object-oriented development present formal semantics object-oriented specification language formal semantics presented conservative shallow embedding Isabelle/hol language oriented towards ocl formula context uml class diagram On basis formally derive several equational tableau calculus form basis integrated proof environment including automatic proof support support analysis type specification show application proof environment data refinement based adapted standard refinement notion Thus provide integrated formal method refinement-based object-oriented development
Correctness recent database replication protocol justified rather informal way focusing safety property without using rigorous formalism Since database replication protocol must ensure degree replica consistency transaction follow given isolation level previous proof focused two issue paper proposes formalization using I/O automaton model identifying several component distributed system involved replication support replication protocol group communication system database replica specifying clearly action global replicated system architecture Then general certification-based replication protocol guaranteeing snapshot isolation level proven correct end different safety liveness property identified checked proved work show detail replication protocol ignored previous correctness justification indeed needed order guarantee proposed correctness criterion Correctness recent database replication protocol justified rather informal way focusing safety property without using rigorous formalism Since database replication protocol must ensure degree replica consistency transaction follow given isolation level previous proof focused two issue paper proposes formalization using I/O automaton model identifying several component distributed system involved replication support replication protocol group communication system database replica specifying clearly action global replicated system architecture Then general certification-based replication protocol guaranteeing snapshot isolation level proven correct end different safety liveness property identified checked proved work show detail replication protocol ignored previous correctness justification indeed needed order guarantee proposed correctness criterion
paper consider finite labelled transition system show transition system deterministic persistent weakly periodic decomposed following sense There exists finite set label-disjoint cycle cycle Parikh-equivalent multiset cycle set paper consider finite labelled transition system show transition system deterministic persistent weakly periodic decomposed following sense There exists finite set label-disjoint cycle cycle Parikh-equivalent multiset cycle set
paper address standing question pattern expression PE namely whether family PE language closed intersection regular language Since family closed complement closed reversal another natural question frequently raised recent year whether particular language mirror language language palindrome PE language give answer related question well thus providing insight descriptional power paper address standing question pattern expression PE namely whether family PE language closed intersection regular language Since family closed complement closed reversal another natural question frequently raised recent year whether particular language mirror language language palindrome PE language give answer related question well thus providing insight descriptional power
Computational complexity comparing behaviour system composed interacting finite-state component considered main result show respective problem EXPTIME-hard relation bisimulation equivalence trace preorder conjectured Rabinovich Inf Comput 139 :111�129 1997 result proved specific model parallel composition component synchronize shared action easily extended similar model labelled 1-safe Petri net Further hardness result shown special case acyclic system Computational complexity comparing behaviour system composed interacting finite-state component considered main result show respective problem EXPTIME-hard relation bisimulation equivalence trace preorder conjectured Rabinovich Inf Comput 139 :111�129 1997 result proved specific model parallel composition component synchronize shared action easily extended similar model labelled 1-safe Petri net Further hardness result shown special case acyclic system
earlier work shown two variant weak fairness expressed comparatively easily timed process algebra PAFAS demonstrate usefulness result complement work Walker Form Asp Comput 1:273�292 1989 study liveness property Dekker � mutual exclusion algorithm within process algebraic setting also present result allow reduce state space PAFAS process representing Dekker � algorithm give insight representation fair behaviour PAFAS earlier work shown two variant weak fairness expressed comparatively easily timed process algebra PAFAS demonstrate usefulness result complement work Walker Form Asp Comput 1:273�292 1989 study liveness property Dekker � mutual exclusion algorithm within process algebraic setting also present result allow reduce state space PAFAS process representing Dekker � algorithm give insight representation fair behaviour PAFAS
Tree-walking tree transducer typechecked double exponential time More generally composition k tree-walking tree transducer typechecked k -fold exponential time Consequently k-pebble tree transducer form model XML transformation XML query typechecked k -fold exponential time result hold ranked unranked tree Tree-walking tree transducer typechecked double exponential time More generally composition k tree-walking tree transducer typechecked k -fold exponential time Consequently k-pebble tree transducer form model XML transformation XML query typechecked k -fold exponential time result hold ranked unranked tree
work propose innovative approach investigate admissibility permutation multistage interconnection networks�a challenging problem switching theory proposed approach centered upon modeling multistage interconnection network colored Petri net use Petri net analysis tool unfolding technique invariant method ass feasibility proposed approach demonstrate complete unfolding obtained work polynomial problem size employ acyclic structure approach take advantage easy use yet extremely efficient software tool work propose innovative approach investigate admissibility permutation multistage interconnection networks�a challenging problem switching theory proposed approach centered upon modeling multistage interconnection network colored Petri net use Petri net analysis tool unfolding technique invariant method ass feasibility proposed approach demonstrate complete unfolding obtained work polynomial problem size employ acyclic structure approach take advantage easy use yet extremely efficient software tool
establish decidability boundary model checking problem infinite-state establish decidability boundary model checking problem infinite-state
system defined Process Rewrite Systems PRS weakly extended Process Rewrite Systems wPRS property described basic fragment action-based Linear Temporal Logic LTL future past operator It known problem general LTL property decidable Petri net pushdown process undecidable PA processes.We show problem decidable wPRS consider property defined LTL formula modality strict eventually strict always past counterpart Moreover show problem remains undecidable PA process even respect LTL fragment modality fragment modality next infinitely often system defined Process Rewrite Systems PRS weakly extended Process Rewrite Systems wPRS property described basic fragment action-based Linear Temporal Logic LTL future past operator It known problem general LTL property decidable Petri net pushdown process undecidable PA processes.We show problem decidable wPRS consider property defined LTL formula modality strict eventually strict always past counterpart Moreover show problem remains undecidable PA process even respect LTL fragment modality fragment modality next infinitely often
prove program terminates employ ranking function argument program state ranked every transition decrease rank Alternatively use set ranking function property every cycle program � flow-chart ranked one function � local � approach gained interest recently ground local ranking function would simpler easier find current study aimed better understanding tradeoff involved precise quantitative sense concentrate convenient setting Size-Change Termination framework SCT SCT program replaced abstraction whose termination decidable Moreover sufficient class ranking function global local known result show tradeoff either exponentially many local function certain simple form exponentially complex global function may required proving termination prove program terminates employ ranking function argument program state ranked every transition decrease rank Alternatively use set ranking function property every cycle program � flow-chart ranked one function � local � approach gained interest recently ground local ranking function would simpler easier find current study aimed better understanding tradeoff involved precise quantitative sense concentrate convenient setting Size-Change Termination framework SCT SCT program replaced abstraction whose termination decidable Moreover sufficient class ranking function global local known result show tradeoff either exponentially many local function certain simple form exponentially complex global function may required proving termination
Semi-synchronously rational relation generalise synchronised rational relation natural way discus basic property among � Cobham�Semenov-like � dichotomy theorem main result characterisation bijective semi-synchronously rational transduction bijections mapping regular relation regular one non-regular relation non-regular one Semi-synchronously rational relation generalise synchronised rational relation natural way discus basic property among � Cobham�Semenov-like � dichotomy theorem main result characterisation bijective semi-synchronously rational transduction bijections mapping regular relation regular one non-regular relation non-regular one
new elegant simple algorithm mutual exclusion N process proposed It requires shared variable memory model shared variable need accessed atomically prove mutual exclusion reformulating algorithm transition system automaton applying simulation automaton proof verified higher-order interactive theorem prover PVS Under additional atomicity assumption algorithm starvation free conjecture competing process passed process conjecture verified model checking system five process new elegant simple algorithm mutual exclusion N process proposed It requires shared variable memory model shared variable need accessed atomically prove mutual exclusion reformulating algorithm transition system automaton applying simulation automaton proof verified higher-order interactive theorem prover PVS Under additional atomicity assumption algorithm starvation free conjecture competing process passed process conjecture verified model checking system five process
regular component either autodense anti-autodense Characterizations regular component pure autodense language pure autodense code obtained relationship intercodes anti-autodense language intercode L index L n anti-autodense language every n > regular component either autodense anti-autodense Characterizations regular component pure autodense language pure autodense code obtained relationship intercodes anti-autodense language intercode L index L n anti-autodense language every n >
scattered context grammar era nonterminals generalized k-limited way successful derivation k positive integer every sentential form derivation substring consisting nonterminals grammar derives empty string length k le paper demonstrates scattered context grammar generates sentence way converted scattered context grammar without erasing production general however possible scattered context grammar era nonterminals generalized k-limited way successful derivation k positive integer every sentential form derivation substring consisting nonterminals grammar derives empty string length k le paper demonstrates scattered context grammar generates sentence way converted scattered context grammar without erasing production general however possible
implication multivalued dependency relational database originally defined context fixed finite universe While axiomatisability implication problem intensely studied respect notion almost research devoted towards alternative notion implication underlying universe attribute left undetermined Based set common inference rule establish axiomatisations undetermined universe axiomatisations fixed universe indicate role complementation rule mean database normalisation characterises expressiveness several incomplete set inference implication multivalued dependency relational database originally defined context fixed finite universe While axiomatisability implication problem intensely studied respect notion almost research devoted towards alternative notion implication underlying universe attribute left undetermined Based set common inference rule establish axiomatisations undetermined universe axiomatisations fixed universe indicate role complementation rule mean database normalisation characterises expressiveness several incomplete set inference
rule also establish relationship axiomatisations fixed undetermined universe rule also establish relationship axiomatisations fixed undetermined universe
study time complexity implication problem undetermined universe result paper establish foundation reasoning multivalued dependency without assumption fixed underlying universe study time complexity implication problem undetermined universe result paper establish foundation reasoning multivalued dependency without assumption fixed underlying universe
state concurrent object intended abstraction value field object usually determines coordination behavior Therefore state always programmer � mind even though implicitly suggest feature Java-like language make state concurrent object explicit support expression object � behavior depending state currently Namely object one state declared class state determines presence field method State transition statement explicitly change state object thus change availability field method When thread call method declared object � class absent current state wait state object change state contain method directly express coordination claim feature make easier understand develop concurrent program substantiate claim discussion popular example concurrent program written using feature.We develop type effect system guarantee execution method invoked concurrent object \tt No attempt made access field available current state \tt No method invoked receiver syntactically different \tt may cause invocation method \tt latter guarantee help enforce former prevents family accidental violation intended coordination protocol state concurrent object intended abstraction value field object usually determines coordination behavior Therefore state always programmer � mind even though implicitly suggest feature Java-like language make state concurrent object explicit support expression object � behavior depending state currently Namely object one state declared class state determines presence field method State transition statement explicitly change state object thus change availability field method When thread call method declared object � class absent current state wait state object change state contain method directly express coordination claim feature make easier understand develop concurrent program substantiate claim discussion popular example concurrent program written using feature.We develop type effect system guarantee execution method invoked concurrent object \tt No attempt made access field available current state \tt No method invoked receiver syntactically different \tt may cause invocation method \tt latter guarantee help enforce former prevents family accidental violation intended coordination protocol
paper survey research related model M-nets since introduced 1995 M-nets high-level labelled Petri net composed like process algebra term using various operator present core model several extension main application paper survey research related model M-nets since introduced 1995 M-nets high-level labelled Petri net composed like process algebra term using various operator present core model several extension main application
Inspired Hoare � rule recursive procedure present three proof rule equivalence recursive program first rule used proving partial equivalence program second used proving mutual termination third rule used proving equivalence reactive program There various application rule proving equivalence program refactoring proving backward compatibility Inspired Hoare � rule recursive procedure present three proof rule equivalence recursive program first rule used proving partial equivalence program second used proving mutual termination third rule used proving equivalence reactive program There various application rule proving equivalence program refactoring proving backward compatibility
investigate model programming specifying higher-order function nondeterminacy demonic angelic coexist model built using predicate transformer binary multirelations state transformer free lattice poset show exist suitable model approach isomorphic model support algebra nondeterminacy use prove classical list fusion law hold even presence nondeterminacy investigate model programming specifying higher-order function nondeterminacy demonic angelic coexist model built using predicate transformer binary multirelations state transformer free lattice poset show exist suitable model approach isomorphic model support algebra nondeterminacy use prove classical list fusion law hold even presence nondeterminacy
Back von Wright developed algebraic law reasoning loop total correctness framework using refinement calculus extend work reasoning probabilistic loop probabilistic refinement calculus apply algebraic reasoning derive transformation rule probabilistic action system probabilistic while-loops particular focus developing data refinement rule two construct extension interesting since well known transformation rule applicable standard program applicable probabilistic one identify important difference develop alternative rule possible Back von Wright developed algebraic law reasoning loop total correctness framework using refinement calculus extend work reasoning probabilistic loop probabilistic refinement calculus apply algebraic reasoning derive transformation rule probabilistic action system probabilistic while-loops particular focus developing data refinement rule two construct extension interesting since well known transformation rule applicable standard program applicable probabilistic one identify important difference develop alternative rule possible
biological process gene assembly transforms nucleus MIC functionally physically different nucleus MAC For gene MIC input recombination operation transform gene MAC form output Here characterize input obtain output moreover characterize possible form output abstract general setting so-called legal string biological process gene assembly transforms nucleus MIC functionally physically different nucleus MAC For gene MIC input recombination operation transform gene MAC form output Here characterize input obtain output moreover characterize possible form output abstract general setting so-called legal string
paper deal foundation concurrency theory show structurally complex concurrent behaviour modelled relational structure X \diamondsuit \sqsubset X set event occurrence \diamondsuit interpreted commutativity \sqsubset interpreted weak causality binary relation X paper continuation approach initiated Gaifman Pratt Proceedings LICS � 87 pp 72�85 1987 Lamport J ACM 33:313�326 1986 Abraham et al Semantics concurrency workshop computing Springer Heidelberg pp 311�323 1990 Janicki Koutny Lect Notes Comput Sci 506:59�74 1991 substantially developed Janicki Koutny Theoretical Computer Science 112:5�52 1993 Janicki Koutny Acta Informatica 34:367�388 1997 recently generalized Guo Janicki Lect Notes Comput Sci 2422:178�191 2002 Janicki Lect Notes Comput Sci 3407:84�98 2005 For first time full model general case given paper deal foundation concurrency theory show structurally complex concurrent behaviour modelled relational structure X \diamondsuit \sqsubset X set event occurrence \diamondsuit interpreted commutativity \sqsubset interpreted weak causality binary relation X paper continuation approach initiated Gaifman Pratt Proceedings LICS � 87 pp 72�85 1987 Lamport J ACM 33:313�326 1986 Abraham et al Semantics concurrency workshop computing Springer Heidelberg pp 311�323 1990 Janicki Koutny Lect Notes Comput Sci 506:59�74 1991 substantially developed Janicki Koutny Theoretical Computer Science 112:5�52 1993 Janicki Koutny Acta Informatica 34:367�388 1997 recently generalized Guo Janicki Lect Notes Comput Sci 2422:178�191 2002 Janicki Lect Notes Comput Sci 3407:84�98 2005 For first time full model general case given
Closures linear context-free language Boolean operation investigated intersection closure complementation closure incomparable By closing closure Boolean operation obtain several new language family hierarchy obtained closure closure proper certain level collapse Boolean closure turn incomparable several closure family context-free language Boolean closure linear context-free language properly contained Boolean closure context-free language characterization class non-unary language expressed Boolean formula linear context-free language presented Closures linear context-free language Boolean operation investigated intersection closure complementation closure incomparable By closing closure Boolean operation obtain several new language family hierarchy obtained closure closure proper certain level collapse Boolean closure turn incomparable several closure family context-free language Boolean closure linear context-free language properly contained Boolean closure context-free language characterization class non-unary language expressed Boolean formula linear context-free language presented
study two-dimensional version bin packing problem conflict given set two-dimensional square V = n side s_1 s_2 \ldots s_n \in [ ] conflict graph G = V E seek find partition item independent set G independent set packed unit square bin two square packed together one bin overlap goal minimize number independent set partition problem generalizes square packing problem E = \emptyset graph coloring problem = = sn It well known coloring problem general graph hard approximate Following previous work one-dimensional problem study problem specific graph class namely bipartite graph perfect graph design 2+\varepsilon -approximation bipartite graph almost best possible unless P = NP For perfect graph design 3.2744-approximation study two-dimensional version bin packing problem conflict given set two-dimensional square V = n side s_1 s_2 \ldots s_n \in [ ] conflict graph G = V E seek find partition item independent set G independent set packed unit square bin two square packed together one bin overlap goal minimize number independent set partition problem generalizes square packing problem E = \emptyset graph coloring problem = = sn It well known coloring problem general graph hard approximate Following previous work one-dimensional problem study problem specific graph class namely bipartite graph perfect graph design 2+\varepsilon -approximation bipartite graph almost best possible unless P = NP For perfect graph design 3.2744-approximation
Relation algebra well suited dealing many problem ordered set Introducing lattice via order relation suggests apply tool mechanization lattice-theoretical problem combine relation algebra BDD-based specific purpose Computer Algebra system RelView solve algorithmic problem order lattice visualize solution Relation algebra well suited dealing many problem ordered set Introducing lattice via order relation suggests apply tool mechanization lattice-theoretical problem combine relation algebra BDD-based specific purpose Computer Algebra system RelView solve algorithmic problem order lattice visualize solution
introduce data structure provides efficient heap operation respect number element comparison performed Let n denote size heap manipulated data structure guarantee worst-case cost O finding minimum inserting element extracting unspecified element replacing element smaller element worst-case cost O lg n lg n lg lg n O element comparison deleting element thereby improve comparison complexity heap operation known run-relaxed heap worst-case efficient heap Furthermore data structure support melding two heap size n worst-case cost O min lg lg n introduce data structure provides efficient heap operation respect number element comparison performed Let n denote size heap manipulated data structure guarantee worst-case cost O finding minimum inserting element extracting unspecified element replacing element smaller element worst-case cost O lg n lg n lg lg n O element comparison deleting element thereby improve comparison complexity heap operation known run-relaxed heap worst-case efficient heap Furthermore data structure support melding two heap size n worst-case cost O min lg lg n
consider model random tree similar split tree Devroye SIAM J. Comput 28 409�432 1998 set item recursively partitioned model allows flexibility choice partitioning procedure weighted edge prove model height H n random tree asymptotic c log n probability constant c uniquely characterized term multivariate large deviation rate function extension permit u obtain height pebbled try pebbled ternary search try d-ary pyramid study geometric property partition generated k-d tree model also includes polynomial family increasing tree recently studied Broutin et al height increasing tree Random Structures Algorithms 2007 press consider model random tree similar split tree Devroye SIAM J. Comput 28 409�432 1998 set item recursively partitioned model allows flexibility choice partitioning procedure weighted edge prove model height H n random tree asymptotic c log n probability constant c uniquely characterized term multivariate large deviation rate function extension permit u obtain height pebbled try pebbled ternary search try d-ary pyramid study geometric property partition generated k-d tree model also includes polynomial family increasing tree recently studied Broutin et al height increasing tree Random Structures Algorithms 2007 press
Kierstead et al SIAM J Discret Math 8:485�498 1995 shown competitive function on-line coloring \mathbb P _5\ -free graph i.e graph without induced path vertex bounded exponential function \left 4^ \chi \mathbb G - 1\right / No nontrivial lower bound known paper show quadratic lower bound \tiny \left \begin array * 20 c \chi \mathbb G \\ \\ \end array \right More precisely prove \tiny \left \begin array * 20 c \chi \mathbb G \\ \\ \end array \right exact competitive function \mathbb C _4 \mathbb P _5\ -free graph paper also prove 2\ \kappa \mathbb G - competitive function best clique covering on-line algorithm \mathbb C _4 \mathbb P _5\ -free graph Kierstead et al SIAM J Discret Math 8:485�498 1995 shown competitive function on-line coloring \mathbb P _5\ -free graph i.e graph without induced path vertex bounded exponential function \left 4^ \chi \mathbb G - 1\right / No nontrivial lower bound known paper show quadratic lower bound \tiny \left \begin array * 20 c \chi \mathbb G \\ \\ \end array \right More precisely prove \tiny \left \begin array * 20 c \chi \mathbb G \\ \\ \end array \right exact competitive function \mathbb C _4 \mathbb P _5\ -free graph paper also prove 2\ \kappa \mathbb G - competitive function best clique covering on-line algorithm \mathbb C _4 \mathbb P _5\ -free graph
paper present data model uncertain data uncertainty represented using interval probability theory introduced paper applied different specific data model entire approach developed independently kind manipulated object like XML document relational tuples data type consequence theory used extend existing data model management uncertainty particular data model obtain application XML data first proposal combine XML interval probability powerful query algebra selection projection cross product cross product operator based assumption independence XML tree different collection Being defined possible world semantics operator proper extension traditional counterpart reduce uncertainty main practical result paper set equivalence used compare rewrite algebraic query interval probabilistic data particular XML relational paper present data model uncertain data uncertainty represented using interval probability theory introduced paper applied different specific data model entire approach developed independently kind manipulated object like XML document relational tuples data type consequence theory used extend existing data model management uncertainty particular data model obtain application XML data first proposal combine XML interval probability powerful query algebra selection projection cross product cross product operator based assumption independence XML tree different collection Being defined possible world semantics operator proper extension traditional counterpart reduce uncertainty main practical result paper set equivalence used compare rewrite algebraic query interval probabilistic data particular XML relational
prove probabilistic bisimilarity decidable probabilistic extension BPA BPP process For normed subclass probabilistic BPA BPP process obtain polynomial-time algorithm Further show probabilistic bisimilarity probabilistic pushdown automaton finite-state system decidable exponential time If number control state PDA bounded fixed constant algorithm need polynomial time prove probabilistic bisimilarity decidable probabilistic extension BPA BPP process For normed subclass probabilistic BPA BPP process obtain polynomial-time algorithm Further show probabilistic bisimilarity probabilistic pushdown automaton finite-state system decidable exponential time If number control state PDA bounded fixed constant algorithm need polynomial time
present two algorithm near optimal respect number inversion present input One algorithm variation insertion sort variation merge sort number comparison performed algorithm input sequence length n I inversion n\ \rm log \frac I n O n Moreover algorithm implementation run time O n\ \rm log \frac I n +\ n All previously published algorithm require least cn\ \rm log \frac I n comparison c > present two algorithm near optimal respect number inversion present input One algorithm variation insertion sort variation merge sort number comparison performed algorithm input sequence length n I inversion n\ \rm log \frac I n O n Moreover algorithm implementation run time O n\ \rm log \frac I n +\ n All previously published algorithm require least cn\ \rm log \frac I n comparison c >
paper investigates satisfiability Propositional Projection Temporal Logic PPTL infinite model decision procedure PPTL formula given end Normal Form NF Labeled Normal Form Graph LNFG PPTL formula defined algorithm transforming formula normal form constructing LNFG given formula presented Further finiteness LNFGs proved detail Moreover decision procedure extended check satisfiability formula Propositional Interval Temporal Logic addition example also given illustrate decision procedure work paper investigates satisfiability Propositional Projection Temporal Logic PPTL infinite model decision procedure PPTL formula given end Normal Form NF Labeled Normal Form Graph LNFG PPTL formula defined algorithm transforming formula normal form constructing LNFG given formula presented Further finiteness LNFGs proved detail Moreover decision procedure extended check satisfiability formula Propositional Interval Temporal Logic addition example also given illustrate decision procedure work
order design analyse complex system modeler need formal model two contradictory requirement high expressivity decidability behavioural property checking Here present develop theory model recursive Petri net First show mechanism supported recursive Petri net enable model pattern discrete event system related dynamic structure process Furthermore prove pattern modelled ordinary Petri net Then study decidability problem reachability finiteness bisimulation At last develop concept linear invariant kind net design efficient computation specifically tailored take advantage structure order design analyse complex system modeler need formal model two contradictory requirement high expressivity decidability behavioural property checking Here present develop theory model recursive Petri net First show mechanism supported recursive Petri net enable model pattern discrete event system related dynamic structure process Furthermore prove pattern modelled ordinary Petri net Then study decidability problem reachability finiteness bisimulation At last develop concept linear invariant kind net design efficient computation specifically tailored take advantage structure
Computing frequent itemsets one prominent problem data mining Recently new related problem called FREQSAT introduced studied given itemset�interval pair exist database every pair frequency itemset fall interval ? paper extend FREQSAT-problem constraining database giving characteristic part input well These characteristic maximal transaction length maximal number transaction maximal number duplicate transaction These extension combination studied depth hierarchy w.r.t complexity given make complete picture also case characteristic constant i.e bounded bound fixed constant part input studied Computing frequent itemsets one prominent problem data mining Recently new related problem called FREQSAT introduced studied given itemset�interval pair exist database every pair frequency itemset fall interval ? paper extend FREQSAT-problem constraining database giving characteristic part input well These characteristic maximal transaction length maximal number transaction maximal number duplicate transaction These extension combination studied depth hierarchy w.r.t complexity given make complete picture also case characteristic constant i.e bounded bound fixed constant part input studied
develop algebraic theory thread synchronous cooperation thread interaction thread Maurer machine investigate program parallelization using resulting theory Program parallelization underlies technique speeding instruction processing computer make use ability computer process instruction simultaneously case state change involved influence One finding strong induction principle needed proving theorem sufficient condition correctness program parallelizations induction principle introduced brought u construct projective limit model theory developed develop algebraic theory thread synchronous cooperation thread interaction thread Maurer machine investigate program parallelization using resulting theory Program parallelization underlies technique speeding instruction processing computer make use ability computer process instruction simultaneously case state change involved influence One finding strong induction principle needed proving theorem sufficient condition correctness program parallelizations induction principle introduced brought u construct projective limit model theory developed
propose exact algorithm counting model propositional formula conjunctive normal form algorithm based detection strong backdoor set bounded size instantiation variable strong backdoor set put given formula class formula model counted polynomial time For backdoor set detection utilize efficient vertex cover algorithm applied certain � obstruction graph � associate given formula approach give rise new hardness index formula clustering-width algorithm run uniform polynomial time formula bounded clustering-width It known number model formula bounded clique-width bounded treewidth bounded branchwidth computed polynomial time graph parameter applied formula via certain hyper graph associated formula show clustering-width parameter mentioned incomparable formula bounded clustering-width arbitrarily large clique-width treewidth branchwidth Conversely formula arbitrarily large clustering-width bounded clique-width treewidth branchwidth propose exact algorithm counting model propositional formula conjunctive normal form algorithm based detection strong backdoor set bounded size instantiation variable strong backdoor set put given formula class formula model counted polynomial time For backdoor set detection utilize efficient vertex cover algorithm applied certain � obstruction graph � associate given formula approach give rise new hardness index formula clustering-width algorithm run uniform polynomial time formula bounded clustering-width It known number model formula bounded clique-width bounded treewidth bounded branchwidth computed polynomial time graph parameter applied formula via certain hyper graph associated formula show clustering-width parameter mentioned incomparable formula bounded clustering-width arbitrarily large clique-width treewidth branchwidth Conversely formula arbitrarily large clustering-width bounded clique-width treewidth branchwidth
Tomita-style generalised LR GLR algorithm extend standard LR algorithm non-deterministic grammar performing possible choice action Cubic complexity achieved rule length two paper shall show achieve cubic time bound grammar binarising search performed whilst executing reduce action GLR-style parser call resulting algorithm Binary Right Nulled GLR BRNGLR parsing binarisation process generates run-time behaviour related shown parser pre-processes grammar parse table binary form without increase table size reduced run-time space overhead BRNGLR parser worst-case cubic run time grammar linear behaviour LR grammar produce worst-case cubic time cubic size binary SPPF representation derivation given sentence Tomita-style generalised LR GLR algorithm extend standard LR algorithm non-deterministic grammar performing possible choice action Cubic complexity achieved rule length two paper shall show achieve cubic time bound grammar binarising search performed whilst executing reduce action GLR-style parser call resulting algorithm Binary Right Nulled GLR BRNGLR parsing binarisation process generates run-time behaviour related shown parser pre-processes grammar parse table binary form without increase table size reduced run-time space overhead BRNGLR parser worst-case cubic run time grammar linear behaviour LR grammar produce worst-case cubic time cubic size binary SPPF representation derivation given sentence
language unbounded demonic angelic nondeterminacy function acquire surprisingly rich set fixpoints show construct fixpoints describe one suitable giving meaning recursively defined function present algebraic law reasoning language level construct model show law sound model employ new kind power domain-like construct accommodating arbitrary nondeterminacy language unbounded demonic angelic nondeterminacy function acquire surprisingly rich set fixpoints show construct fixpoints describe one suitable giving meaning recursively defined function present algebraic law reasoning language level construct model show law sound model employ new kind power domain-like construct accommodating arbitrary nondeterminacy
Starting succession rule Catalan number define procedure encoding listing object enumerated number two consecutive code list differ one digit Gray code obtain generalized succession rule stability property label k production two label c c always position regardless k. Because link define Gray structure set combinatorial object whose construction encoded succession rule stability property property characteristic found among various succession rule finite factorial transcendental one also indicate algorithm slight modification Walsh � one working O worst-case time per word generating Gray code Starting succession rule Catalan number define procedure encoding listing object enumerated number two consecutive code list differ one digit Gray code obtain generalized succession rule stability property label k production two label c c always position regardless k. Because link define Gray structure set combinatorial object whose construction encoded succession rule stability property property characteristic found among various succession rule finite factorial transcendental one also indicate algorithm slight modification Walsh � one working O worst-case time per word generating Gray code
Given query workload database set constraint view-selection problem select view materialize constraint satisfied view used compute query workload efficiently typical constraint consider present work require view stored given amount disk space Depending feature SQL query DISTINCT keyword whether database relation query applied set bag query may computed set semantics bag-set semantics bag semantics paper study complexity view-selection problem conjunctive query view semantics show bag semantics � easiest handle � show case decision version view selection NP whereas set bag-set semantics assume restriction query workload allow query without self-joins workload achieve complexity Moreover bag bag-set semantics filtering view i.e subgoals dropped rewriting without impacting equivalence query practically needed set semantics filtering view reduce significantly query-evaluation cost show set semantics decision version view-selection problem remains NP filtering view allowed rewriting Finally investigate whether cgalg algorithm view selection introduced Chirkova Genesereth Linearly bounded reformulations conjunctive database pp 987�1001 2000 suitable setting prove algorithm sound case examine complete bag semantics workload arbitrary conjunctive query bag-set semantics workload conjunctive query without self-joins Given query workload database set constraint view-selection problem select view materialize constraint satisfied view used compute query workload efficiently typical constraint consider present work require view stored given amount disk space Depending feature SQL query DISTINCT keyword whether database relation query applied set bag query may computed set semantics bag-set semantics bag semantics paper study complexity view-selection problem conjunctive query view semantics show bag semantics � easiest handle � show case decision version view selection NP whereas set bag-set semantics assume restriction query workload allow query without self-joins workload achieve complexity Moreover bag bag-set semantics filtering view i.e subgoals dropped rewriting without impacting equivalence query practically needed set semantics filtering view reduce significantly query-evaluation cost show set semantics decision version view-selection problem remains NP filtering view allowed rewriting Finally investigate whether cgalg algorithm view selection introduced Chirkova Genesereth Linearly bounded reformulations conjunctive database pp 987�1001 2000 suitable setting prove algorithm sound case examine complete bag semantics workload arbitrary conjunctive query bag-set semantics workload conjunctive query without self-joins
improve undecidability bound problem involving two integer matrix showing Scalar Reachability Zero Right Upper Corner Vector Reachability Zero Left Upper Corner undecidable dimension 10 11 13 respectively Problems Scalar Reachability Zero Right Upper Corner Vector Reachability previously known undecidable dimension 18 18 16 respectively improve undecidability bound problem involving two integer matrix showing Scalar Reachability Zero Right Upper Corner Vector Reachability Zero Left Upper Corner undecidable dimension 10 11 13 respectively Problems Scalar Reachability Zero Right Upper Corner Vector Reachability previously known undecidable dimension 18 18 16 respectively
study hairpin-free word initiated context DNA computing DNA strand theoretically speaking finite string alphabet G C T used DNA computing encode information Due fact complementary T G C DNA single strand complementary bind either intended unintended way One structure usually undesirable biocomputation since make affected DNA string unavailable future interaction hairpin subsequence DNA single string complementary string bind forming hairpin-like structure paper continues theoretical study hairpin-free language study algebraic property hairpin-free word hairpin also give complete characterization syntactic monoid language consisting hairpin-free word given alphabet illustrate example using DNA alphabet study hairpin-free word initiated context DNA computing DNA strand theoretically speaking finite string alphabet G C T used DNA computing encode information Due fact complementary T G C DNA single strand complementary bind either intended unintended way One structure usually undesirable biocomputation since make affected DNA string unavailable future interaction hairpin subsequence DNA single string complementary string bind forming hairpin-like structure paper continues theoretical study hairpin-free language study algebraic property hairpin-free word hairpin also give complete characterization syntactic monoid language consisting hairpin-free word given alphabet illustrate example using DNA alphabet
recursive descent parsing method context-free grammar extended generalization Boolean grammar include explicit set-theoretic operation formalism rule formally defined language equation algorithm applicable subset Boolean grammar complexity direct implementation varies linear exponential memoization keep linear recursive descent parsing method context-free grammar extended generalization Boolean grammar include explicit set-theoretic operation formalism rule formally defined language equation algorithm applicable subset Boolean grammar complexity direct implementation varies linear exponential memoization keep linear
With growing use eXtensible Markup Language XML database technology format permanent storage data topic functional dependency XML XFDs assumed increased importance central role database design Recently two different approach proposed defining XFD first us concept � tree tuple � whereas second us concept � closest node � general two approach comparable comparable Document Type Definition present missing information XML document first contribution article show two XFD definition comparable definition equivalent essentially common definition XFD complete XML document second contribution provide justification definition � closest node � XFD show complete flat relation mapped XML document arbitrary sequence nest operation XML document satisfies � closest node � XFD relation satisfies corresponding functional dependency class XML document generated fashion subset class XML document two definition XFDs coincide Hence � tree tuple � � closest node � XFDs capture semantics FDs complete relation mapped XML document via arbitrary nesting With growing use eXtensible Markup Language XML database technology format permanent storage data topic functional dependency XML XFDs assumed increased importance central role database design Recently two different approach proposed defining XFD first us concept � tree tuple � whereas second us concept � closest node � general two approach comparable comparable Document Type Definition present missing information XML document first contribution article show two XFD definition comparable definition equivalent essentially common definition XFD complete XML document second contribution provide justification definition � closest node � XFD show complete flat relation mapped XML document arbitrary sequence nest operation XML document satisfies � closest node � XFD relation satisfies corresponding functional dependency class XML document generated fashion subset class XML document two definition XFDs coincide Hence � tree tuple � � closest node � XFDs capture semantics FDs complete relation mapped XML document via arbitrary nesting
paper introduces notion well-structured language well-structured language defined labelled well-structured transition system equipped upward-closed set accepting state That peculiar class transition system extensively studied field computer-aided verification direct important application Petri net monotonic extension like Petri net non-blocking arc Petri net transfer arc instance special subclass well-structured transition system show class well-structured language enjoy several important closure property propose several pumping lemma applicable respectively whole class well-structured language class language recognized Petri net Petri net non-blocking arc These pumping lemma allow u characterize limit expressiveness class language Furthermore exploit pumping lemma strictly separate expressive power Petri net Petri net non-blocking arc Petri net transfer arc paper introduces notion well-structured language well-structured language defined labelled well-structured transition system equipped upward-closed set accepting state That peculiar class transition system extensively studied field computer-aided verification direct important application Petri net monotonic extension like Petri net non-blocking arc Petri net transfer arc instance special subclass well-structured transition system show class well-structured language enjoy several important closure property propose several pumping lemma applicable respectively whole class well-structured language class language recognized Petri net Petri net non-blocking arc These pumping lemma allow u characterize limit expressiveness class language Furthermore exploit pumping lemma strictly separate expressive power Petri net Petri net non-blocking arc Petri net transfer arc
Threads contained thread algebra emerge behavioral abstraction program appropriate program algebra Threads may make use service stack thread using single stack called pushdown thread Equivalence pushdown thread shown decidable whereas pushdown thread inclusion undecidable example borderline crossing equivalence problem decidable whereas inclusion problem Threads contained thread algebra emerge behavioral abstraction program appropriate program algebra Threads may make use service stack thread using single stack called pushdown thread Equivalence pushdown thread shown decidable whereas pushdown thread inclusion undecidable example borderline crossing equivalence problem decidable whereas inclusion problem
When infinitary rewriting introduced Kaplan et al Principles Programming Languages ACM New York pp 250�259 1989 beginning 1990s term universe explained metric completion metric finite term motivation connection topology allowed import well-studied notion metric space particular notion convergence replacement normalisation paper generalises approach parameterising term metric applying process metric completion term also operation relation term resulting meta-theory studied leading revised notion infinitary rewrite system For system method devised prove convergence When infinitary rewriting introduced Kaplan et al Principles Programming Languages ACM New York pp 250�259 1989 beginning 1990s term universe explained metric completion metric finite term motivation connection topology allowed import well-studied notion metric space particular notion convergence replacement normalisation paper generalises approach parameterising term metric applying process metric completion term also operation relation term resulting meta-theory studied leading revised notion infinitary rewrite system For system method devised prove convergence
Concurrent reactive program specified behaviour presence nondeterministic environment natural way give specification ARW atomic variable style Abadi Lamport Several implementation atomic variable lower level primitive known year ago formulated criterion prove correctness implementation proof correctness criterion based Lynch � definition atomicity serialization point Here criterion reformulated specification HRW formal sense Simulations HRW ARW vice versa constructed These serve constructive proof correctness criterion Eternity variable used simulation HRW ARW propose so-called gliding simulation deal problem appear occasionally concrete implementation need fewer step abstract specification Concurrent reactive program specified behaviour presence nondeterministic environment natural way give specification ARW atomic variable style Abadi Lamport Several implementation atomic variable lower level primitive known year ago formulated criterion prove correctness implementation proof correctness criterion based Lynch � definition atomicity serialization point Here criterion reformulated specification HRW formal sense Simulations HRW ARW vice versa constructed These serve constructive proof correctness criterion Eternity variable used simulation HRW ARW propose so-called gliding simulation deal problem appear occasionally concrete implementation need fewer step abstract specification
deterministic parallel LL parsing algorithm presented algorithm based transformation parsing problem parallel reduction First nondeterministic version parallel LL parser introduced Then transformed deterministic version�the LLP parser deterministic LLP q k parser us two kind information select next operation � lookahead string length k symbol lookback string length q symbol Deterministic parsing available LLP grammar subclass LL grammar Since presented deterministic nondeterministic parallel parser based parallel reduction suitable parallel architecture deterministic parallel LL parsing algorithm presented algorithm based transformation parsing problem parallel reduction First nondeterministic version parallel LL parser introduced Then transformed deterministic version�the LLP parser deterministic LLP q k parser us two kind information select next operation � lookahead string length k symbol lookback string length q symbol Deterministic parsing available LLP grammar subclass LL grammar Since presented deterministic nondeterministic parallel parser based parallel reduction suitable parallel architecture
Asian option popular financial derivative security Unfortunately exact pricing formula exist price continuous-time model Asian option also priced lattice discretized version continuous- time model But exponential-time algorithm exist option priced lattice without approximation Although efficient approximation method available lack accuracy guarantee general paper proposes novel lattice structure pricing Asian option resulting pricing algorithm exact i.e without approximation converges value continuous-time model run subexponential time first exact convergent lattice algorithm break long-standing exponential-time barrier Asian option popular financial derivative security Unfortunately exact pricing formula exist price continuous-time model Asian option also priced lattice discretized version continuous- time model But exponential-time algorithm exist option priced lattice without approximation Although efficient approximation method available lack accuracy guarantee general paper proposes novel lattice structure pricing Asian option resulting pricing algorithm exact i.e without approximation converges value continuous-time model run subexponential time first exact convergent lattice algorithm break long-standing exponential-time barrier
paper investigate standard model checker applied checking refinement relationship Z specification major obstacle use potentially infinite data domain specification Consequently examine application data abstraction technique reducing infinite finite state space Since data abstraction however decrease amount information specification refinement can�in general�not proven abstraction anymore disproved model checker thus used generate counter example refinement relationship Here show abstract specification systematically constructed given data abstraction standard model checker FDR applied find counter example case refinement absent especially discus applicability construction method construct abstract specification either upward downward simulation original specification depending operation specification data abstraction chosen construction might succeed fail construction abstract input/output well state paper investigate standard model checker applied checking refinement relationship Z specification major obstacle use potentially infinite data domain specification Consequently examine application data abstraction technique reducing infinite finite state space Since data abstraction however decrease amount information specification refinement can�in general�not proven abstraction anymore disproved model checker thus used generate counter example refinement relationship Here show abstract specification systematically constructed given data abstraction standard model checker FDR applied find counter example case refinement absent especially discus applicability construction method construct abstract specification either upward downward simulation original specification depending operation specification data abstraction chosen construction might succeed fail construction abstract input/output well state
Based analysis capability operator Calculus Mobile Ambients three fairness principle proposed safeguard interaction ambients Calculus Fair Ambient designed meet fairness principle labeled transition semantics calculus defined support structural investigation bisimulation theory fair ambients studied two coincidence result established An expressiveness result calculus formally established proving contains pi calculus sub-calculus Based analysis capability operator Calculus Mobile Ambients three fairness principle proposed safeguard interaction ambients Calculus Fair Ambient designed meet fairness principle labeled transition semantics calculus defined support structural investigation bisimulation theory fair ambients studied two coincidence result established An expressiveness result calculus formally established proving contains pi calculus sub-calculus

